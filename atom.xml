<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lefo&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/4d1e20579d737b72764e8d457f1900cd</icon>
  <subtitle>又一个android开发人员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lefo.me/"/>
  <updated>2021-02-24T11:01:56.688Z</updated>
  <id>http://www.lefo.me/</id>
  
  <author>
    <name>lefo</name>
    <email>lephones#lephones.net(#换成@你懂得)</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用jenkins为android工程打包，支持多包名，改资源（优化方案）</title>
    <link href="http://www.lefo.me/2020/09/04/jenkins-android-3/"/>
    <id>http://www.lefo.me/2020/09/04/jenkins-android-3/</id>
    <published>2020-09-04T15:32:15.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>没有需求，自己看了一眼自己之前写的打包脚本，简直无法看下去。而且，产品经理的定制化需求越来越多，用shell脚本的可读性也越来越差，再加上里面一堆的sed命令，惨不忍睹。</p><p>改!!!</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>gradle其实支持自定义参数，关于自定义参数的介绍，参考官方文档：<a href="https://docs.gradle.org/current/userguide/build_environment.html，简单说一下用到的：[Gradle" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/build_environment.html，简单说一下用到的：[Gradle</a> properties](<a href="https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties)：" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties)：</a></p><p>有两种方式传给gradle，一种是-P。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew clean -Pname=zhangsan</span><br></pre></td></tr></table></figure><p>另一种是gradle.properties，我们可以在build.gradle文件所在的目录下创建一个gradle.properties文件，写上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=zhangsan</span><br></pre></td></tr></table></figure><p>通过这两种方式，在gradle脚本中就可以直接使用这个变量名。</p><a id="more"></a><p>比如如下的gradle配置，其中包含了int型，String型，boolean型，基本能满足需求了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildConfigField &quot;boolean&quot;, &quot;SHOW_INFO&quot;, &quot;$SHOW_INFO&quot;</span><br><span class="line">applicationId &quot;$PACKAGE_NAME&quot;</span><br><span class="line"></span><br><span class="line">versionCode Integer.valueOf(VERSION_CODE)</span><br><span class="line">versionName VERSION_NAME</span><br><span class="line"></span><br><span class="line">buildConfigField &quot;String&quot;, &quot;QQ_ID&quot;, &quot;\&quot;$qq_id\&quot;&quot;</span><br><span class="line">buildConfigField &quot;String&quot;, &quot;WX_RELEASE_ID&quot;, &quot;\&quot;$wx_id\&quot;&quot;</span><br></pre></td></tr></table></figure><p>对应的gradle.properties文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VERSION_NAME=1.2</span><br><span class="line">VERSION_CODE=1110</span><br><span class="line">PACKAGE_NAME=me.lefo.jenkins</span><br><span class="line">SHOW_INFO=true</span><br><span class="line">qq_id=1001</span><br><span class="line">wx_id=1002</span><br></pre></td></tr></table></figure><h1 id="结合jenkins的参数化构建"><a href="#结合jenkins的参数化构建" class="headerlink" title="结合jenkins的参数化构建"></a>结合jenkins的参数化构建</h1><p>通常用jenkins在构建的时候，都会自定义一些参数，比如上文的VERSION_NAME，VERSION_CODE。当然，我们还有个奇葩的需求，改包名。</p><p>jenkins在搭建的时候，构建那一步一定要选<code>invoke gradle script</code>，点开下面的高级选项，勾选<code>Pass all job parameters as Project properties</code>，勾选这一项会将jenkins参数化构建时的参数写到gradle中，还会替换掉gradle.properties中的默认值。其实就是通过-P把参数传到了gradle，-P传入的优先级高于properties文件。</p><p><strong>一定要保证参数名和gradle.properties文件中的名字一样！！！</strong></p><p><strong>一定要保证参数名和gradle.properties文件中的名字一样！！！</strong></p><p><strong>一定要保证参数名和gradle.properties文件中的名字一样！！！</strong></p><h1 id="和包名绑定的配置"><a href="#和包名绑定的配置" class="headerlink" title="和包名绑定的配置"></a>和包名绑定的配置</h1><p>我们有个改包名的需求，有些配置化的值，是要跟着包名变动的，比如第三方平台的id。怎么办呢？这里的做法是，不同包名，建立不同的properties文件，执行时，使用cp -f命令，替换掉gradle.properties文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -f $PACKAGE_NAME.properties gradle.properties</span><br></pre></td></tr></table></figure><p>像一些构建时jenkins传入的参数，可以不在<code>包名.properties</code>里出现，但是，默认的gradle.properties文件必须有这些值，在as run的时候，还是得在gradle.properties中有个默认值的。但jenkins选了<code>invoke gradle script</code>，这些参数会通过-P传进去。</p><h1 id="manifest文件"><a href="#manifest文件" class="headerlink" title="manifest文件"></a>manifest文件</h1><p>manifest文件中，也会配置一些值，可以通过placeHolder传进去。比如channel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">manifestPlaceholders = [label:&quot;@string/app_name&quot;,</span><br><span class="line">                                channel:&quot;$CHANNEL&quot;]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在manifest中可以通过${channel}来使用，manifest中的authorities也可以通过这种方式来处理。</p><h1 id="改应用名"><a href="#改应用名" class="headerlink" title="改应用名"></a>改应用名</h1><p>我们有两个需求，一个是改用户界面显示的应用名，另一个是改APP内部显示的应用名，这两个有可能不一样。这里当然是通过sed改的，貌似也没有别的办法，上一段中的label也是用于这个功能的。我们的做法是把包含应用名关键字的strings.xml单独提取到一个value资源文件，然后通过sed统一修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &apos;s/默认应用名/&apos;&quot;$APP_NAME&quot;&apos;/g&apos; myflavor/res/values/stringfile.xml</span><br></pre></td></tr></table></figure><h1 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h1><p>通过这波修改，之前的一坨sh文件中，就只剩下修改应用名的脚本了，其它的都通过gradle的环境变量来支持了。后续如果要加配置项，只需要在gradle.properties中加个默认项，如果是跟包名的，就放在包名.properties中，如果是jenkins配置的，就按对应的名称配在jenkins就OK。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;p&gt;没有需求，自己看了一眼自己之前写的打包脚本，简直无法看下去。而且，产品经理的定制化需求越来越多，用shell脚本的可读性也越来越差，再加上里面一堆的sed命令，惨不忍睹。&lt;/p&gt;
&lt;p&gt;改!!!&lt;/p&gt;
&lt;h1 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h1&gt;&lt;p&gt;gradle其实支持自定义参数，关于自定义参数的介绍，参考官方文档：&lt;a href=&quot;https://docs.gradle.org/current/userguide/build_environment.html，简单说一下用到的：[Gradle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.gradle.org/current/userguide/build_environment.html，简单说一下用到的：[Gradle&lt;/a&gt; properties](&lt;a href=&quot;https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties)：&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties)：&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有两种方式传给gradle，一种是-P。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gradlew clean -Pname=zhangsan&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另一种是gradle.properties，我们可以在build.gradle文件所在的目录下创建一个gradle.properties文件，写上&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;name=zhangsan&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过这两种方式，在gradle脚本中就可以直接使用这个变量名。&lt;/p&gt;
    
    </summary>
    
      <category term="android打包" scheme="http://www.lefo.me/categories/android%E6%89%93%E5%8C%85/"/>
    
    
      <category term="android" scheme="http://www.lefo.me/tags/android/"/>
    
      <category term="jenkins" scheme="http://www.lefo.me/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>android进程保活（掌握黑心科技）</title>
    <link href="http://www.lefo.me/2020/08/24/keep-alive/"/>
    <id>http://www.lefo.me/2020/08/24/keep-alive/</id>
    <published>2020-08-24T21:31:23.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h1><p>android这个生态真的是不好，从一开始，大家就想方设法在后台常驻，为了让自己app不被杀，绞尽脑汁想各种存活办法。</p><p>目前，之前用的大部分保活方案，在手机上几乎都是失效的，尤其是一些国内厂家机型，提供一键清理功能，把你正的运行的APP，杀的渣也不剩。</p><p>所以，目前还能正常使用的方法就只有一种，那就是两个进程互相监听。</p><a id="more"></a><h1 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h1><p>B发现A死了后，赶紧把A拉活，然后再把自己杀死，这样达到瞒天过海的效果。</p><h2 id="启动子进程"><a href="#启动子进程" class="headerlink" title="启动子进程"></a>启动子进程</h2><p>方案一：就是fork。fork会分离出一个子进程，在fork的地方开始执行接下来的工作，可以根据fork函数返回值来判断是主进程还是子进程。这里提到的另一个概念就是二次fork，关于二次fork和进程托孤，可以自行上网了解一下。</p><p>方案二：使用app_process命令启动一个java进程。<a href="https://blog.csdn.net/u010651541/article/details/53163542" target="_blank" rel="noopener">https://blog.csdn.net/u010651541/article/details/53163542</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app_process &lt;dir&gt; &lt;class name&gt; &lt;parameters&gt; --application --nice-name=nice_name</span><br><span class="line">app_process -Djava.class.path=Helloworld.dex  dir classname</span><br></pre></td></tr></table></figure><p>当然了，要想启动java进程，classpath得设置，如执行export CLASSPATH，也可以使用-D来指定路径。如果有so要调用，还要将共享库加到环境变量中。export LD_LIBRARY_PATH 或者export _LD_LIBRARY_PATH</p><h2 id="两个进程如何互相监听"><a href="#两个进程如何互相监听" class="headerlink" title="两个进程如何互相监听"></a>两个进程如何互相监听</h2><p>这里有一个相当巧妙的方式，使用linux提供的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int flock(int fd,LOCK_EX);</span><br></pre></td></tr></table></figure><p>具体用法请自行搜索，简单讲，A进程调用该函数后，此时B进程再调用，会造成B进程阻塞。而当A进程挂了后，B进程就会立马继续执行。</p><h2 id="如何拉活APP"><a href="#如何拉活APP" class="headerlink" title="如何拉活APP"></a>如何拉活APP</h2><p>要获取ams的IBinder，然后调用transact来启动组件。这里给大家提供源代码的路径，这里需要用反射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mRemote = android.os.ServiceManager.getService(&quot;activity&quot;)</span><br><span class="line">mRemote.transact(code,data,null,FLAG_ONEWAY);</span><br></pre></td></tr></table></figure><p>这里有两部分需要处理，一个是code值，另一个就是data。关于code值，不同的安卓版本不一样，另外有的rom也会修改，翻看源码android.app.IActivityManager。</p><p>关于data，也会根据不同的系统版本有不同的拼装方法。我这里以service为例。具体参数，也可以参考源码，下面的写法也是根据IActivityManager不同版本中的startService写的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mServiceData = Parcel.obtain();</span><br><span class="line">mServiceData.writeInterfaceToken(&quot;android.app.IActivityManager&quot;);</span><br><span class="line">mServiceData.writeStrongBinder(null);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= 26) &#123;</span><br><span class="line">    mServiceData.writeInt(1);</span><br><span class="line">&#125;</span><br><span class="line">//这个是service的intent</span><br><span class="line">serviceIntent.writeToParcel(mServiceData, 0);</span><br><span class="line">mServiceData.writeString(null);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= 26) &#123;</span><br><span class="line">    //fg service</span><br><span class="line">    mServiceData.writeInt(1);</span><br><span class="line">&#125;</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">    String packageName = serviceIntent.getComponent().getPackageName();</span><br><span class="line">    mServiceData.writeString(packageName);</span><br><span class="line">&#125;</span><br><span class="line">mServiceData.writeInt(0);</span><br></pre></td></tr></table></figure><p>我声明一下，service保活在部分手机上可用。</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>其实有比较完善的demo，保活效果很不错，但这个话题有点敏感，不想放，写这篇blog就是记录一下其中的一两个点关键。本文只有一些支离破碎的片段，不想搞的整个环境乌烟瘴气，手机里一个个APP成了流氓软件，也防止引发一些其它纠纷。</p><p>这个黑科技，还是有点恶心人的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程保活&quot;&gt;&lt;a href=&quot;#进程保活&quot; class=&quot;headerlink&quot; title=&quot;进程保活&quot;&gt;&lt;/a&gt;进程保活&lt;/h1&gt;&lt;p&gt;android这个生态真的是不好，从一开始，大家就想方设法在后台常驻，为了让自己app不被杀，绞尽脑汁想各种存活办法。&lt;/p&gt;
&lt;p&gt;目前，之前用的大部分保活方案，在手机上几乎都是失效的，尤其是一些国内厂家机型，提供一键清理功能，把你正的运行的APP，杀的渣也不剩。&lt;/p&gt;
&lt;p&gt;所以，目前还能正常使用的方法就只有一种，那就是两个进程互相监听。&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://www.lefo.me/categories/android/"/>
    
    
      <category term="android" scheme="http://www.lefo.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>python+selenium为你自动挂海淀驾校法陪课</title>
    <link href="http://www.lefo.me/2020/05/18/python-selenium/"/>
    <id>http://www.lefo.me/2020/05/18/python-selenium/</id>
    <published>2020-05-18T20:25:12.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在北京摇号摇了18次了，下次开始就是四倍概率。然后，中签还是遥遥无期，隔壁坐的同事摇了两年就摇到了，万分羡慕。有时候晚上想去溜达一下，要去找gofun共享汽车还要走1公里多，还车还要走1公里。于是就有了想买一辆摩托车的想法。</p><p>要买车，肯定得有驾照，挑选完以后，报了海淀驾校，小区门口就有驾校的班车，关键是便宜，只要1000块。在我家那18线城市的小地方也得800多。于是报名，开始上法陪课。但法陪课每一章节必须自已手动点开始，很是麻烦，于是就想写个程序代替自己手点。</p><a id="more"></a><h2 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h2><p>法陪课可以在网页上上，也可以在APP上上，没自动播放，估计也是想让你好好学习，怕你偷懒吧。</p><p>因为我是做安卓的，起先打算拿在手机上搞，发现手机上是个自定义控件，基本不能用辅助功能（类似微信抢红包插件的技术）下手。唯一可用的就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -s device_name shell input tap x y</span><br></pre></td></tr></table></figure><p>然后多久发一次命令又是个问题，于是就打算从网页上下手。</p><h2 id="网页端"><a href="#网页端" class="headerlink" title="网页端"></a>网页端</h2><p>网页上看，播放视频是一个flash，想用javascript也就没办法搞了，只得用selenium。</p><p>准备工作：</p><ul><li>Python：不解释</li><li>selenium: pip3 install selenium安装</li><li>Firefox：浏览器，本来我使用的是chrome，发现chrome对flash做了个优化，切后台后，flash不自动加载，换火狐就没问题了。</li><li>geckodriver:火狐浏览器的驱动，供selenium调用</li></ul><h1 id="放代码"><a href="#放代码" class="headerlink" title="放代码"></a>放代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.action_chains import ActionChains</span><br><span class="line">from selenium.webdriver import FirefoxOptions</span><br><span class="line">from selenium.webdriver.support.wait import WebDriverWait</span><br><span class="line">import re</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def findTime(dr):</span><br><span class="line">    timeText = driver.find_element_by_class_name(&apos;playing&apos;).text</span><br><span class="line">    p1 = re.compile(r&apos;[(](.*?)[)]&apos;, re.S)</span><br><span class="line">    timeList = re.findall(p1, timeText)</span><br><span class="line">    if len(timeList) == 0:</span><br><span class="line">        return 0</span><br><span class="line">    else:</span><br><span class="line">        timearr = timeList[0].split(&apos;:&apos;)</span><br><span class="line">        return int(timearr[1]) * 60 + int(timearr[2])</span><br><span class="line"></span><br><span class="line">#flash的事件不能通过element触发 </span><br><span class="line">def click_locxy(dr, x, y, left_click=True):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    dr:浏览器</span><br><span class="line">    x:页面x坐标</span><br><span class="line">    y:页面y坐标</span><br><span class="line">    left_click:True为鼠标左键点击，否则为右键点击</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    if left_click:</span><br><span class="line">        ActionChains(dr).move_by_offset(x, y).click().perform()</span><br><span class="line">    else:</span><br><span class="line">        ActionChains(dr).move_by_offset(x, y).context_click().perform()</span><br><span class="line">    ActionChains(dr).move_by_offset(-x, -y).perform()  # 将鼠标位置恢复到移动前</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">opts = FirefoxOptions()</span><br><span class="line">#opts.add_argument(&quot;--headless&quot;)</span><br><span class="line">option_profile = webdriver.FirefoxProfile()</span><br><span class="line">option_profile.set_preference(&quot;plugin.state.flash&quot;,2)</span><br><span class="line"></span><br><span class="line">path = &quot;/Users/lefo/Documents/dev/chrome/geckodriver&quot;# 注意这个路径需要时可执行路径（chmod 777 dir or 755 dir）</span><br><span class="line">driver = webdriver.Firefox(executable_path=path,options=opts)</span><br><span class="line">driver.get(&apos;http://www.xuechebu.com/sign.html&apos;)</span><br><span class="line">def playing():</span><br><span class="line">    playing = WebDriverWait(driver,60,1).until(lambda x:x.find_element_by_class_name(&apos;playing&apos;)) #等一分钟，直到获取到正在播放的控件</span><br><span class="line">    text = playing.text</span><br><span class="line">    print(text)</span><br><span class="line">    time.sleep(3) #等三秒，有时候文字可能加载慢</span><br><span class="line">    nextTime = findTime(dr=driver) #文字中提取括号内的时间</span><br><span class="line">    playing.click() #这里貌似无所谓，不点击也可以</span><br><span class="line">    print(str(nextTime))  #下一次执行的时间</span><br><span class="line">    time.sleep(10) #这个10s主要是为了flash允许有时间点</span><br><span class="line">    click_locxy(driver,750,540,left_click=True) #根据坐标点上去</span><br><span class="line">    time.sleep(nextTime + 5)  #这个5s和上面10s同样的道理</span><br><span class="line">count = 0</span><br><span class="line">while(count &lt;= 99):  #99这个数值具体自己设</span><br><span class="line">    playing()</span><br><span class="line">    count = count +1</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>首先，获取正在播放的超链接，上面文字的格式：第x章节(00:02:30)表示2分30秒长，计算成秒，然后间隔这个时间值再去下一个循环。因为播放完成后会自动跳到下一个章节，只是不会开始播放而已，所以，我们要做的就是，间隔一段时间，点一下播放。</p><p>试过传入启动flash插件的参数，最后也失败了，所以启动后需要在一分钟内登录，然后去 附加组件 - 插件 将flash插件启用。再将页面上的flash点个允许。点完允许后，10s内会触发一次播放点击。如果你觉得1分钟的登录时间不够，那就改一下上面的时间，或者，加上登录的逻辑（其实我是有登录的，发文章的时候，删掉了）</p><p>如果你是其它挂课的网页，道理也是相同的，如果用JS可以实现还是用js吧。因为这个网页有flash的特殊性，才用的selenium，我对python和selenium都不熟，里面的函数几乎一个都不知道，只能边学边搜边写。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在北京摇号摇了18次了，下次开始就是四倍概率。然后，中签还是遥遥无期，隔壁坐的同事摇了两年就摇到了，万分羡慕。有时候晚上想去溜达一下，要去找gofun共享汽车还要走1公里多，还车还要走1公里。于是就有了想买一辆摩托车的想法。&lt;/p&gt;
&lt;p&gt;要买车，肯定得有驾照，挑选完以后，报了海淀驾校，小区门口就有驾校的班车，关键是便宜，只要1000块。在我家那18线城市的小地方也得800多。于是报名，开始上法陪课。但法陪课每一章节必须自已手动点开始，很是麻烦，于是就想写个程序代替自己手点。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.lefo.me/categories/python/"/>
    
    
      <category term="python" scheme="http://www.lefo.me/tags/python/"/>
    
      <category term="selenium" scheme="http://www.lefo.me/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV在Android NDK按需要的模块编译</title>
    <link href="http://www.lefo.me/2020/05/02/opencv-android/"/>
    <id>http://www.lefo.me/2020/05/02/opencv-android/</id>
    <published>2020-05-02T17:04:20.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司要做一个和图片有关的功能，一说图片处理，大家首先想到的就是强大的OpenCV。OpenCV很强大，官方也提供了android专用的sdk，直接将so和jar放入项目中就能使用。尽管官方推荐的也是这种方式，但有一个问题是，OpenCV的库很大，有10MB，很多公司整个APK都没有10MB，如果要把真个库都放到项目中，那还是挺大的。所以，这里就需要我们自己编译。中间折腾了好久，写个文章记录一下。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="下载OpenCV"><a href="#下载OpenCV" class="headerlink" title="下载OpenCV"></a>下载OpenCV</h2><p>地址 <a href="https://opencv.org/releases/" target="_blank" rel="noopener">https://opencv.org/releases/</a><br>选择Android平台的包</p><p>这里注意了，4.0的版本，要求api level是21以上，所以，如果你的APP是要在21以下使用，不要下载这个。</p><p>3.x的版本不清楚，但我试了OpenCV 2.x的版本是api level 8以上。2.x的版本，需要自行google，官方应该已经不提供了。</p><a id="more"></a><h2 id="配置gradle"><a href="#配置gradle" class="headerlink" title="配置gradle"></a>配置gradle</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">defaultConfig</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">ndkVersion &quot;16.1.4479499&quot;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ndk &#123;</span><br><span class="line">            moduleName &quot;opencv-test&quot;</span><br><span class="line">            abiFilters &apos;armeabi-v7a&apos;,&apos;x86&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path &quot;src/main/jni/CMakeLists.txt&quot;</span><br><span class="line">            version &quot;3.10.2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面的ndkVersion可以不填，我这里是为了使用OpenCV 2.X版本，应该是需要r16的版本编译，因为使用当前最新的版本编译时，有个库找不到。</p><p>abi需要哪些请根据你自己的需要来填，有很多新入门的朋友抄的时候都不看内容，否则如果你其它so库在某平台缺失，可能会闪退。</p><p>CMakeLists.txt注意对应的目录是你JNI代码的目录</p><h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><p>在网上找的一个内容折腾了好久，终于算是弄明白了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#你的opencv解压目录</span><br><span class="line">set(OpenCV_DIR /OpenCV-android-sdk/sdk/native/jni)</span><br><span class="line">#这里也可以在后面跟具体模块OpenCV REQUIRED core imgproc 注意，写上并不代表会编译到包内</span><br><span class="line">FIND_PACKAGE(OpenCV REQUIRED)</span><br><span class="line">if(OpenCV_FOUND)</span><br><span class="line">    include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line">    message(STATUS &quot;OpenCV library status:&quot;)</span><br><span class="line">    message(STATUS &quot;    version: $&#123;OpenCV_VERSION&#125;&quot;)</span><br><span class="line">    message(STATUS &quot;    libraries: $&#123;OpenCV_LIBS&#125;&quot;)</span><br><span class="line">    message(STATUS &quot;    include path: $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;)</span><br><span class="line">else(OpenCV_FOUND)</span><br><span class="line">    message(FATAL_ERROR &quot;OpenCV library not found&quot;)</span><br><span class="line">endif(OpenCV_FOUND)</span><br><span class="line">#你的库</span><br><span class="line">add_library( native_test</span><br><span class="line">        SHARED</span><br><span class="line">        native.cpp)</span><br><span class="line"></span><br><span class="line">#include为头文件所在的目录hpp</span><br><span class="line">include_directories(/OpenCV-android-sdk/sdk/native/jni/include)</span><br><span class="line"></span><br><span class="line">#要链接的库</span><br><span class="line">target_link_libraries( native_test</span><br><span class="line">        $&#123;OpenCV_LIBS&#125;</span><br><span class="line">        log</span><br><span class="line">        jnigraphics)</span><br></pre></td></tr></table></figure></p><p>简单说一下上面的代码</p><ol><li>首先设置OpenCV_DIR环境变量，指定所在目录</li><li>找出配置的所包含的库，也就是OpenCV的模块</li><li>环境的打印，不用在意</li><li>add_library是你的库的配置，可以参考ndk的官方文档</li><li>include_directories是OpenCV的头文件目录</li><li>target_link_libraries这里要用到jnigraphics，还有日志打印的log（常用），注意看OpenCV_LIBS就是FIND_PACKAGE的内容，在3中会打印出来。</li></ol><p>搭建完后你就可以在代码中编写你的jni代码了，这样写出来的库，只会包含你用到的模块，比如你只用到了core和imgproc，那你的库打出来就只有1.8mb，这比OpenCV官方的要小了好多。</p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>写代码的时候，不要使用OpenCV的imread，这会导致有需要多导入模块，增加了包的体积。ndk中，有android/bitmap.h，可以直接使用Bitmap对象来转Mat.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;公司要做一个和图片有关的功能，一说图片处理，大家首先想到的就是强大的OpenCV。OpenCV很强大，官方也提供了android专用的sdk，直接将so和jar放入项目中就能使用。尽管官方推荐的也是这种方式，但有一个问题是，OpenCV的库很大，有10MB，很多公司整个APK都没有10MB，如果要把真个库都放到项目中，那还是挺大的。所以，这里就需要我们自己编译。中间折腾了好久，写个文章记录一下。&lt;/p&gt;
&lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;h2 id=&quot;下载OpenCV&quot;&gt;&lt;a href=&quot;#下载OpenCV&quot; class=&quot;headerlink&quot; title=&quot;下载OpenCV&quot;&gt;&lt;/a&gt;下载OpenCV&lt;/h2&gt;&lt;p&gt;地址 &lt;a href=&quot;https://opencv.org/releases/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://opencv.org/releases/&lt;/a&gt;&lt;br&gt;选择Android平台的包&lt;/p&gt;
&lt;p&gt;这里注意了，4.0的版本，要求api level是21以上，所以，如果你的APP是要在21以下使用，不要下载这个。&lt;/p&gt;
&lt;p&gt;3.x的版本不清楚，但我试了OpenCV 2.x的版本是api level 8以上。2.x的版本，需要自行google，官方应该已经不提供了。&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://www.lefo.me/categories/android/"/>
    
    
      <category term="android" scheme="http://www.lefo.me/tags/android/"/>
    
      <category term="opencv" scheme="http://www.lefo.me/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>jenkins中实用的插件</title>
    <link href="http://www.lefo.me/2020/02/15/jenkins-plugins/"/>
    <id>http://www.lefo.me/2020/02/15/jenkins-plugins/</id>
    <published>2020-02-15T02:27:04.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><p>最近疫情闹的有点凶，大家都是在家办公，刚好群里的一个妹子一边卖萌，一边问jenkins的搭建及使用，就用腾讯会议给辅导了一下。给她讲完后，翻了翻之前给公司搭建的环境，想记录一下之前使用过的Jenkins插件，供以后使用。</p><p>暂时就这些，有好用的插件会不定时更新。</p><h2 id="自带插件"><a href="#自带插件" class="headerlink" title="自带插件"></a>自带插件</h2><p>安装的时候，会提示你要选哪些插件，建议默认，像git svn以及gradle，这些插件会在默认插件列表里就存在。</p><h2 id="Git-Parameter"><a href="#Git-Parameter" class="headerlink" title="Git Parameter"></a>Git Parameter</h2><p>可用于把git的tag branch当作构建参数传进来，方便使用branch构建。</p><h2 id="SVN-Parameter"><a href="#SVN-Parameter" class="headerlink" title="SVN Parameter"></a>SVN Parameter</h2><p>同Git Parameter 一样是可以将tag branch当作构建参数传进来。</p><a id="more"></a><h2 id="Multiple-SCMs-plugin"><a href="#Multiple-SCMs-plugin" class="headerlink" title="Multiple SCMs plugin"></a>Multiple SCMs plugin</h2><p>可以加多个源码的插件，比如我们项目就是资源单独有一个SVN，所以要把代码checkout以后，再checkout资源。</p><h2 id="Environment-Injector-Plugin"><a href="#Environment-Injector-Plugin" class="headerlink" title="Environment Injector Plugin"></a>Environment Injector Plugin</h2><p>可以在构建时注入一些环境变量，这款插件有一个好处就是，它支持<code>Prepare an environment for the run</code>，可以在SCM以前注入变量，比如我们有个资源的svn地址，需要在构建时传进来然后checkout。为了更直观，参数默认值就留了空。有了这个插件，写了groovy脚本，手动将空值改成了默认资源地址，SCM那里直接使用参数名就OK了。</p><h2 id="Version-Number-Plug-In"><a href="#Version-Number-Plug-In" class="headerlink" title="Version Number Plug-In"></a>Version Number Plug-In</h2><p>用于自定义构建记录的名字的插件，使构建记录更直观，不再是#1 #2这种格式。</p><h2 id="Build-Keeper-Plugin"><a href="#Build-Keeper-Plugin" class="headerlink" title="Build Keeper Plugin"></a>Build Keeper Plugin</h2><p>可以按天数保留几天内的构建，没什么大用，如果硬盘紧张，推荐使用自带的Discard old builds</p><h2 id="Role-based-Authorization-Strategy"><a href="#Role-based-Authorization-Strategy" class="headerlink" title="Role-based Authorization Strategy"></a>Role-based Authorization Strategy</h2><p>按项目分权限，比如某个project不想让某人访问到，可以用这个插件。</p><h2 id="Copy-Artifact"><a href="#Copy-Artifact" class="headerlink" title="Copy Artifact"></a>Copy Artifact</h2><p>可以将上游JOB构建后生成的Artifact，复制到下游的JOB来使用，比如上游的JOB生成的apk。</p><h2 id="Validating-String-Parameter-Plugin"><a href="#Validating-String-Parameter-Plugin" class="headerlink" title="Validating String Parameter Plugin"></a>Validating String Parameter Plugin</h2><p>用于参数校验的插件，像产品打包的时候versionCode总是喜欢空着，说多少次都不长心，还让开发看一下为什么打包失败，最后就使用了这个插件，输入时校验。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;记录&quot;&gt;&lt;a href=&quot;#记录&quot; class=&quot;headerlink&quot; title=&quot;记录&quot;&gt;&lt;/a&gt;记录&lt;/h1&gt;&lt;p&gt;最近疫情闹的有点凶，大家都是在家办公，刚好群里的一个妹子一边卖萌，一边问jenkins的搭建及使用，就用腾讯会议给辅导了一下。给她讲完后，翻了翻之前给公司搭建的环境，想记录一下之前使用过的Jenkins插件，供以后使用。&lt;/p&gt;
&lt;p&gt;暂时就这些，有好用的插件会不定时更新。&lt;/p&gt;
&lt;h2 id=&quot;自带插件&quot;&gt;&lt;a href=&quot;#自带插件&quot; class=&quot;headerlink&quot; title=&quot;自带插件&quot;&gt;&lt;/a&gt;自带插件&lt;/h2&gt;&lt;p&gt;安装的时候，会提示你要选哪些插件，建议默认，像git svn以及gradle，这些插件会在默认插件列表里就存在。&lt;/p&gt;
&lt;h2 id=&quot;Git-Parameter&quot;&gt;&lt;a href=&quot;#Git-Parameter&quot; class=&quot;headerlink&quot; title=&quot;Git Parameter&quot;&gt;&lt;/a&gt;Git Parameter&lt;/h2&gt;&lt;p&gt;可用于把git的tag branch当作构建参数传进来，方便使用branch构建。&lt;/p&gt;
&lt;h2 id=&quot;SVN-Parameter&quot;&gt;&lt;a href=&quot;#SVN-Parameter&quot; class=&quot;headerlink&quot; title=&quot;SVN Parameter&quot;&gt;&lt;/a&gt;SVN Parameter&lt;/h2&gt;&lt;p&gt;同Git Parameter 一样是可以将tag branch当作构建参数传进来。&lt;/p&gt;
    
    </summary>
    
      <category term="jenkins" scheme="http://www.lefo.me/categories/jenkins/"/>
    
    
      <category term="jenkins" scheme="http://www.lefo.me/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Git中rebase的常规使用</title>
    <link href="http://www.lefo.me/2020/01/09/git-rebase/"/>
    <id>http://www.lefo.me/2020/01/09/git-rebase/</id>
    <published>2020-01-09T20:21:39.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>公司从svn版本管理切换成了git，Android Studio（Intellij IDEA）也可以较好的支持git，相当方便。git有一个特别强大的命令，那就是rebase，这篇blog就记一下git rebase的一些使用。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://git-scm.com/docs/git-rebase" target="_blank" rel="noopener">https://git-scm.com/docs/git-rebase</a></p><h2 id="一个不错的操作模拟"><a href="#一个不错的操作模拟" class="headerlink" title="一个不错的操作模拟"></a>一个不错的操作模拟</h2><p><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">https://learngitbranching.js.org/</a></p><a id="more"></a><h1 id="git-rebase的常用操作"><a href="#git-rebase的常用操作" class="headerlink" title="git rebase的常用操作"></a>git rebase的常用操作</h1><p>本文不另辟捷径，官方文档讲的很详细，就挑几个官方的例子翻译一下。</p><h2 id="案例1-："><a href="#案例1-：" class="headerlink" title="案例1 ："></a>案例1 ：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase master</span><br><span class="line">git rebase master topic</span><br></pre></td></tr></table></figure><p>上面两条命令，执行其中的一条就可以，执行以后。其实就是git rebase upstream branch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              A&apos;--B&apos;--C&apos; topic</span><br><span class="line">             /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure><h2 id="案例2：–onto的使用"><a href="#案例2：–onto的使用" class="headerlink" title="案例2：–onto的使用"></a>案例2：–onto的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;]</span><br><span class="line">[--onto &lt;newbase&gt; | --keep-base] [&lt;upstream&gt; [&lt;branch&gt;]]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o---o---o---o---o  master</span><br><span class="line">     \</span><br><span class="line">      o---o---o---o---o  next</span><br><span class="line">                       \</span><br><span class="line">                        o---o---o  topic</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto master next topic</span><br></pre></td></tr></table></figure><p>执行的结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o---o---o---o---o  master</span><br><span class="line">    |            \</span><br><span class="line">    |             o&apos;--o&apos;--o&apos;  topic</span><br><span class="line">     \</span><br><span class="line">      o---o---o---o---o  next</span><br></pre></td></tr></table></figure></p><p>这里–onto的后面有三个参数（其实属于–onto的就一个）</p><ol><li>参数1：要跟随在哪个commit，可以是分支名，也可以是commit的 Revision Number</li><li>参数2：after-this-commit 意思是，从这个commit之后的开始算，这个commit是不算的</li><li>参数3：要操作的最后一个commit，这个本身是要算进去的。</li></ol><h2 id="复制一段commits到另一个分支（as应该不支持）"><a href="#复制一段commits到另一个分支（as应该不支持）" class="headerlink" title="复制一段commits到另一个分支（as应该不支持）"></a>复制一段commits到另一个分支（as应该不支持）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---B---C---D---E  master</span><br><span class="line">     \</span><br><span class="line">      F---G---H---I---J---K---L---M  topic</span><br></pre></td></tr></table></figure><p>比如想把K L M的提交copy到master上，那么可以使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git rebase --onto E J M</span><br><span class="line">git rebase HEAD master</span><br></pre></td></tr></table></figure></p><p>结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---B---C---D---E---K‘---L’---M‘  master</span><br><span class="line">     \</span><br><span class="line">      F---G---H---I---J---K---L---M  topic</span><br></pre></td></tr></table></figure></p><p>注意这里一定要<code>git rebase HEAD master</code>，因为执行了第二条rebase后，只是复制了一份commit过去，需要处理一下master和HEAD。</p><h2 id="案例3：合并多条commit为一条"><a href="#案例3：合并多条commit为一条" class="headerlink" title="案例3：合并多条commit为一条"></a>案例3：合并多条commit为一条</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i &lt;after-this-commit&gt;</span><br></pre></td></tr></table></figure><p>执行上述命令后，会让你配置每一项的处理方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pick ：不做任何修改；</span><br><span class="line">reword：只修改提交注释信息；</span><br><span class="line">edit：修改提交的文件，做增补提交；</span><br><span class="line">squash：将该条提交合并到上一条提交，提交注释也一并合并；</span><br><span class="line">fixup：将该条提交合并到上一条提交，废弃该条提交的注释；</span><br></pre></td></tr></table></figure></p><h1 id="关于Android-Studio"><a href="#关于Android-Studio" class="headerlink" title="关于Android Studio"></a>关于Android Studio</h1><p>AS内置的插件可以满足大部分功能，按command + 9可以唤出来log tab<br>附上操作指南：<br><a href="https://www.jetbrains.com/help/idea/edit-project-history.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/edit-project-history.html</a></p><p>我试了试，最终在as里没有找到 –onto 复制一段commits的方式，因为第三个参数必须得选branch，在stackoverflow里，找到一处资料。对比可以看到，如果和上述一段commits，是缺少参数的，所以这里得用命令行了。实际中，也劝大家尽量不要用这种方式。</p><blockquote><p>The rebase dialog in IntelliJ 12.1 uses the most general version of the rebase command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; git rebase [-i] [--onto newbase] [upstream] [branch]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>where IntelliJ’s “Onto” field corresponds to –onto newbase, IntelliJ’s “From” field corresponds to “upstream” and IntelliJ’s “Branch” field corresponds to “branch”.</p><p><a href="https://stackoverflow.com/questions/14608812/how-to-do-interactive-rebase-with-intellij-idea" target="_blank" rel="noopener">https://stackoverflow.com/questions/14608812/how-to-do-interactive-rebase-with-intellij-idea</a></p></blockquote><p>注意AS中，也可以勾选-i参数</p><p>如果是只有一条提交记录，通常用cherry-pick很方便，rebase可以用来处理多条commits的时候。当然，你也可以把commit先执行squash，再执行cherry-pick。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;git&quot;&gt;&lt;a href=&quot;#git&quot; class=&quot;headerlink&quot; title=&quot;git&quot;&gt;&lt;/a&gt;git&lt;/h1&gt;&lt;p&gt;公司从svn版本管理切换成了git，Android Studio（Intellij IDEA）也可以较好的支持git，相当方便。git有一个特别强大的命令，那就是rebase，这篇blog就记一下git rebase的一些使用。&lt;/p&gt;
&lt;h2 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://git-scm.com/docs/git-rebase&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一个不错的操作模拟&quot;&gt;&lt;a href=&quot;#一个不错的操作模拟&quot; class=&quot;headerlink&quot; title=&quot;一个不错的操作模拟&quot;&gt;&lt;/a&gt;一个不错的操作模拟&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://learngitbranching.js.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://learngitbranching.js.org/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://www.lefo.me/categories/git/"/>
    
    
      <category term="git" scheme="http://www.lefo.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>android 8.0 foregroud-service的坑</title>
    <link href="http://www.lefo.me/2019/12/13/foregroud-service-oreo/"/>
    <id>http://www.lefo.me/2019/12/13/foregroud-service-oreo/</id>
    <published>2019-12-13T18:15:23.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ForegroudService"><a href="#ForegroudService" class="headerlink" title="ForegroudService"></a>ForegroudService</h1><p>都知道8.0以后，不可以在后台调用startService()来启动一个服务，要想通过startService启动，必须activity在前台时才能使用。当然onResume和onPause状态下的activity都可以。但是，也有一种情况是例外。</p><p><a href="https://developer.android.com/about/versions/oreo/background#services" target="_blank" rel="noopener">https://developer.android.com/about/versions/oreo/background#services</a></p><p>这里在官方文档也有讲，就是： 进入后台时，在一个持续数分钟的时间窗内，应用仍可以创建和使用 Service。 也就是，当你的activity刚进入后台时，是可以调用startService的。</p><p>如果不使用startService，就得使用startForegroundService，但是需要绑定一个通知，可以在调用时传入通知id，也可以在调用后，通过startForeground来绑定。</p><p>然而，除了以上，还是有一些疏忽了的，需要注意的地方。</p><a id="more"></a><h2 id="使用了startForegroudService还是有错"><a href="#使用了startForegroudService还是有错" class="headerlink" title="使用了startForegroudService还是有错"></a>使用了startForegroudService还是有错</h2><p>做了8.0兼容后，已经把所有的startService都改成了startForegroundService，但是后台还是得到了很多的错误，特别是在android 8.0 和8.1的机子上。</p><p>android.app.RemoteServiceException: Context.startForegroundService() did not then call Service.startForeground()</p><p>经过排查，测试，发现还有一些需要注意的点，这里大概列一下。</p><h2 id="可以不调用notify方法"><a href="#可以不调用notify方法" class="headerlink" title="可以不调用notify方法"></a>可以不调用notify方法</h2><p>首先，要想启动一个前台服务，必须使用startForegroundService，只要调用了startForegroundService，必须调用startForeground为其设置一个notification。</p><p>注意：这里的notification可以不调用notify方法，但是，在调用startForeground后，会自动调用这个notify方法将notification展示出来。</p><h2 id="stopSelf前要startForeground"><a href="#stopSelf前要startForeground" class="headerlink" title="stopSelf前要startForeground"></a>stopSelf前要startForeground</h2><p>google文档显示，如果在5s内未调用startForeground，则系统将停止此Service并声明此应用为ANR。那么，5s内如果stopSelf()呢？？亲测，这样也不行，按常理分析，如果直接调用stopSelf可行，是有违ForegroudService的设计初衷的。所以，在stopSelf前，如果想一个startForegroundService调用后直接关闭，也是需要调用startForeground()的。</p><h2 id="stopForeground不要乱用"><a href="#stopForeground不要乱用" class="headerlink" title="stopForeground不要乱用"></a>stopForeground不要乱用</h2><p>stopForeground是将一个service从前台改为后台的，如果你中途调用了stopForeground，再次调用startForegroundService时，一但没有走到startForeground，（比如是在onCreate方法中，就不会走到）还是会报出Context.startForegroundService() did not then call Service.startForeground()的异常，所以，看清楚再使用它。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ForegroudService&quot;&gt;&lt;a href=&quot;#ForegroudService&quot; class=&quot;headerlink&quot; title=&quot;ForegroudService&quot;&gt;&lt;/a&gt;ForegroudService&lt;/h1&gt;&lt;p&gt;都知道8.0以后，不可以在后台调用startService()来启动一个服务，要想通过startService启动，必须activity在前台时才能使用。当然onResume和onPause状态下的activity都可以。但是，也有一种情况是例外。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/about/versions/oreo/background#services&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.android.com/about/versions/oreo/background#services&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里在官方文档也有讲，就是： 进入后台时，在一个持续数分钟的时间窗内，应用仍可以创建和使用 Service。 也就是，当你的activity刚进入后台时，是可以调用startService的。&lt;/p&gt;
&lt;p&gt;如果不使用startService，就得使用startForegroundService，但是需要绑定一个通知，可以在调用时传入通知id，也可以在调用后，通过startForeground来绑定。&lt;/p&gt;
&lt;p&gt;然而，除了以上，还是有一些疏忽了的，需要注意的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://www.lefo.me/categories/android/"/>
    
    
      <category term="android" scheme="http://www.lefo.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>python入门：使用python刷自如的房子</title>
    <link href="http://www.lefo.me/2019/07/31/python-ziroom/"/>
    <id>http://www.lefo.me/2019/07/31/python-ziroom/</id>
    <published>2019-07-31T16:43:48.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错过房子"><a href="#错过房子" class="headerlink" title="错过房子"></a>错过房子</h1><p>自如在北京租房行业上占据着龙头地位，它们的房租也是一年比一年高，特别是新签约的房子，价格很是离谱。但偶尔也会有一两个换租的房子，性价比超级高。如果有自己比较中意的小区，想监控里面的房子，我就有一次看中一个房子，看到的时候，就已经晚了，等想签的时候，被别人抢先了。这个脚本，可以在某小区有新房源的时候，第一时间通知自己。</p><a id="more"></a><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ol><li>python 2.x 语言及运行环境</li><li>tesseract ocr 这是google的一款图片识别文字的软件，需要安装库，自行搜索python+tesseract</li><li>支持smtp协议的邮箱，建议新注册一个。</li><li>绑定微信的QQ的邮箱。</li></ol><p>安装python和tesseract就不讲了，主要说一下tesseract。其实没有这个也不重要，主要是自如的房子，价格是一张图片。然后用坐标截取相应的数字生成价格图，比如坐标是[8,9,2,1]，那价格就是1345元。其实只要发送房子id就行，去官网看一下，价格就有了。</p><p><img src="/image/20190731/price.png" alt></p><p>使用邮箱，主要是为了方便微信接收，微信可以绑定QQ邮箱。只要给QQ发送邮件，微信就可以收到信息。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol><li>发送请求，搜索关键字 <a href="http://m.ziroom.com/v7/room/list.json?city_code=110000&amp;type=11&amp;keywords=" target="_blank" rel="noopener">http://m.ziroom.com/v7/room/list.json?city_code=110000&amp;type=11&amp;keywords=</a>   后面跟上要搜索的关键字。type=11是一居室,具体参数，可以通过<a href="http://m.ziroom.com/" target="_blank" rel="noopener">http://m.ziroom.com</a>，上面选择搜索信息后，可以查看到具体的type。</li><li>拿到列表，解析房源信息。</li><li>拿到房子价格图片，识别出内容，根据坐标拼出房价及单元（日租和月租）</li><li>检查数据库中是否保存过该房源（已经发送过）</li><li>分页会再请求下一页。</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码用定时任务跑在了我的服务器上，每隔一段时间跑一下。</p><p>写python比较少，再加上后来改代码时，直接用ssh连接的服务器用vi改的，导致代码写的比较乱。</p><p>我把信息保存到了ziroom.db里，是sqlite格式。价格为了不每次都请求，也缓存到了image文件夹下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import sqlite3</span><br><span class="line">import urllib</span><br><span class="line">import urllib2</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line">import json</span><br><span class="line">import smtplib</span><br><span class="line">import pytesseract</span><br><span class="line">import time</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.header import Header</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line"># 第三方 SMTP 服务</span><br><span class="line">mail_host=&quot;&quot;  #设置服务器</span><br><span class="line">mail_user=&quot;&quot;    #用户名</span><br><span class="line">mail_pass=&quot;&quot;   #口令 </span><br><span class="line">sender = &quot;&quot;#发送邮箱 一般等同于用户名</span><br><span class="line">receivers = [&apos;2323354557@qq.com&apos;]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱</span><br><span class="line"></span><br><span class="line">BaseURL = &apos;http://m.ziroom.com/v7/room/list.json?city_code=110000&amp;type=11&amp;keywords=&apos;  </span><br><span class="line">#keywords = &apos;%E9%BE%99%E5%8D%8E%E5%9B%AD&apos;</span><br><span class="line">keywords = [&apos;华清嘉园&apos; , &apos;展春园&apos;]</span><br><span class="line">cur_page = 1</span><br><span class="line">room_string = &apos;&apos;</span><br><span class="line"></span><br><span class="line">def sendEmail(content,keyword):</span><br><span class="line">message = MIMEText(content, &apos;plain&apos;, &apos;utf-8&apos;)</span><br><span class="line">message[&apos;From&apos;] = &apos;自如&lt;&apos;+sender+&apos;&gt;&apos;</span><br><span class="line">message[&apos;To&apos;] =  &apos;lefo&lt;2323354557@qq.com&gt;&apos;</span><br><span class="line"></span><br><span class="line">subject = &apos;有&apos;+ keyword +&apos;的新房子了&apos;</span><br><span class="line">message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">smtpObj = smtplib.SMTP() </span><br><span class="line">smtpObj.connect(mail_host, 25)    # 25 为 SMTP 端口号</span><br><span class="line">smtpObj.login(mail_user,mail_pass)  </span><br><span class="line">smtpObj.sendmail(sender, receivers, message.as_string())</span><br><span class="line">print(&quot;邮件发送成功&quot;)</span><br><span class="line">except smtplib.SMTPException as e:</span><br><span class="line">print(e);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getJson(URL,page,keyword):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">global cur_page</span><br><span class="line">global room_string</span><br><span class="line"></span><br><span class="line">send_headers = &#123;</span><br><span class="line">    &apos;Host&apos;:&apos;m.ziroom.com&apos;,</span><br><span class="line">    &apos;User-Agent&apos;:&apos;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1&apos;,</span><br><span class="line">    &apos;Accept&apos;:&apos;application/json;version=6&apos;,</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">url = URL +&apos;&amp;page=&apos; + page;</span><br><span class="line">req = urllib2.Request(url,headers=send_headers)</span><br><span class="line"></span><br><span class="line">content = urllib2.urlopen(req).read().decode(&apos;utf-8&apos;)</span><br><span class="line">data = json.loads(content)</span><br><span class="line">rooms = data[&apos;data&apos;][&apos;rooms&apos;];</span><br><span class="line">print(URL)</span><br><span class="line">print(content)</span><br><span class="line"></span><br><span class="line">for room in rooms:</span><br><span class="line">tags =&apos;&apos;</span><br><span class="line">for tag in room[&apos;tags&apos;]:</span><br><span class="line">tags +=(&apos; &apos; + (tag[&apos;title&apos;]))</span><br><span class="line">#print (room[&apos;id&apos;] + room[&apos;face&apos;] + &apos; &apos; + room[&apos;name&apos;] + tags + room[&apos;price&apos;])</span><br><span class="line">cursor = c.execute(&quot;SELECT * from ROOM WHERE ZID=&quot; + room[&apos;id&apos;])</span><br><span class="line">result = cursor.fetchall()</span><br><span class="line"></span><br><span class="line">if len(result) &lt;= 0:</span><br><span class="line">pricedata = room[&apos;price&apos;]</span><br><span class="line">priceurl = &apos;http:&apos; + pricedata[0]</span><br><span class="line">print(priceurl)</span><br><span class="line">path = &quot;image/&quot; + os.path.basename(pricedata[0])</span><br><span class="line">if not os.path.exists(path):</span><br><span class="line">res = urllib.urlopen(priceurl).read()</span><br><span class="line">f = open(path,&quot;wb&quot;)</span><br><span class="line">f.write(res)</span><br><span class="line">f.close()</span><br><span class="line">img = Image.open(path)</span><br><span class="line">print(path)</span><br><span class="line">imgprice = pytesseract.image_to_string(img,lang=&apos;eng&apos;,config=&apos;-psm 7&apos;)</span><br><span class="line">print(imgprice)</span><br><span class="line">price = &apos;&apos;</span><br><span class="line">unit = room[&apos;price_unit&apos;]</span><br><span class="line">if len(imgprice)&gt;0:</span><br><span class="line">for index in pricedata[1]:</span><br><span class="line">price =price + imgprice[index]</span><br><span class="line">roomInfo = room[&apos;id&apos;] + &apos; &apos; +  room[&apos;name&apos;] + &apos; &apos; + price + unit</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">room_string = room_string + roomInfo + &apos;\n&apos;</span><br><span class="line">sql = &apos;INSERT INTO ROOM (ZID,HID,TITLE) VALUES (&quot;&apos; + room[&apos;id&apos;] +&apos;&quot;,&quot;&apos;  + room[&apos;house_id&apos;]+&apos;&quot;,&quot;&apos; + room[&apos;name&apos;] +&apos;&quot;)&apos;</span><br><span class="line">c.execute(sql )</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line">if len(rooms) &gt; 0:</span><br><span class="line">cur_page += 1</span><br><span class="line">getJson(BaseURL + urllib.quote(keyword),str(cur_page),keyword)</span><br><span class="line">else:</span><br><span class="line">if len(room_string) &gt; 0:</span><br><span class="line">print(&apos;send email \n&apos; + room_string)</span><br><span class="line">sendEmail(room_string,keyword)</span><br><span class="line">room_string = &apos;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(&apos;ziroom.db&apos;)</span><br><span class="line">c = conn.cursor()</span><br><span class="line">c.execute(&apos;&apos;&apos;CREATE TABLE IF NOT EXISTS ROOM</span><br><span class="line">       (ID INTEGER PRIMARY KEY AUTOINCREMENT     NOT NULL,</span><br><span class="line">   ZID           TEXT     NOT NULL,</span><br><span class="line">       HID           TEXT     NOT NULL,</span><br><span class="line">       TITLE        CHAR(50));&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line">for keyword in keywords:</span><br><span class="line">cur_page = 1</span><br><span class="line">keywordsquote = urllib.quote(keyword)</span><br><span class="line">getJson(BaseURL + keywordsquote,str(cur_page),keyword)</span><br></pre></td></tr></table></figure><h1 id="自行优化"><a href="#自行优化" class="headerlink" title="自行优化"></a>自行优化</h1><p>说一下优化的事，自如的房子有各种状态，参数名叫status，后续，可以把代码加一个状态的判断。比如status == ‘dzz’是待租中，还有退租配置中，最关键的是，有一个释放倒计时的状态。这样可以实现某个房子的要释放时，提前通知自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;错过房子&quot;&gt;&lt;a href=&quot;#错过房子&quot; class=&quot;headerlink&quot; title=&quot;错过房子&quot;&gt;&lt;/a&gt;错过房子&lt;/h1&gt;&lt;p&gt;自如在北京租房行业上占据着龙头地位，它们的房租也是一年比一年高，特别是新签约的房子，价格很是离谱。但偶尔也会有一两个换租的房子，性价比超级高。如果有自己比较中意的小区，想监控里面的房子，我就有一次看中一个房子，看到的时候，就已经晚了，等想签的时候，被别人抢先了。这个脚本，可以在某小区有新房源的时候，第一时间通知自己。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.lefo.me/categories/python/"/>
    
    
      <category term="python" scheme="http://www.lefo.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>从zip结构看APK采集时优化</title>
    <link href="http://www.lefo.me/2019/07/08/zip-file-struct/"/>
    <id>http://www.lefo.me/2019/07/08/zip-file-struct/</id>
    <published>2019-07-08T17:44:20.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现有采集"><a href="#现有采集" class="headerlink" title="现有采集"></a>现有采集</h1><p>都知道APK就是一个zip包，目前，收集别人家的APK信息，原理都一样，一般都是先将APK文件下载，再提取AndroidManifest.xml，通过<code>AXmlPrint2.jar</code>打开，得到反编译后的xml，解析xml得到包信息。</p><p>那么，一个游戏好几个GB，真正用到的却只有几KB信息。如果能跳过内容，结合断点下载，直接下载到AndroidManifest.xml，那就能省很多流量了。</p><a id="more"></a><h1 id="分析ZIP"><a href="#分析ZIP" class="headerlink" title="分析ZIP"></a>分析ZIP</h1><p>图文并茂的文章：<a href="https://blog.csdn.net/hp910315/article/details/77717746" target="_blank" rel="noopener">https://blog.csdn.net/hp910315/article/details/77717746</a></p><p>表格介绍的文章：<a href="https://blog.csdn.net/a200710716/article/details/51644421" target="_blank" rel="noopener">https://blog.csdn.net/a200710716/article/details/51644421</a></p><p>上面这两篇文章很详细的介绍了zip文件的结构，我再简单提一下，zip是先保存的文件，最后又将文件信息做了个目录放在最后。如下：</p><p><strong>[文件实体头+文件数据+数据描述符][..重复..]+核心目录+目录结束标识</strong></p><p>核心目录是关键内容，结构为重复n个[文件头]，也就是，所有在zip中重复的文件，都有会在核心目录区保存一些关键信息(文件信息，不含文件内容)。其中，包含了每个文件在zip中起始偏移、压缩后的大小，所以，只要我们拿到核心目录的内容，就可以定位到AndroidManifest.xml的位置。</p><p>附上两张图：</p><p>manifest文件实体头</p><p><img src="/image/20190708/zip-header.jpg" alt="manifest文件实体头"></p><p>manifest核心目录</p><p><img src="/image/20190708/zip-dir.jpg" alt="manifest核心目录"></p><h1 id="关键头"><a href="#关键头" class="headerlink" title="关键头"></a>关键头</h1><p>核心目录中，每个文件头的标记位开始都是4个字节<code>0x02014b50</code>，在文件中，高位是在后面存放的，所以，要找的4个字节是0x50，0x4b，0x01，0x02。找到以后，根据对应的偏移，来找到文件名、文件名长度、压缩后大小以及在文件中的位置。</p><p>我只列举一下用到的位置</p><table><thead><tr><th>offset</th><th>大小(字节)</th><th>代表意义</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>0x02014b50</td></tr><tr><td>20</td><td>4</td><td>压缩后文件大小</td></tr><tr><td>28</td><td>2</td><td>文件名长度(n)</td></tr><tr><td>42</td><td>4</td><td>文件保存的位置</td></tr><tr><td>46</td><td>文件名长度(n)</td><td>文件名</td></tr></tbody></table><p>找到文件保存的位置和大小后，直接读取成字节数组，然后使用<code>ZipInputStream</code>解压。</p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>文件分为：文件头、文件数据、数据描述符</p><p>文件头后面，就是文件内容了，但是，这些我们都不用关注，我们只需要拿到最开始0x04034b50所在的位置就行。因为ZipInputStream调用getNextEntry可以直接读取。</p><p>实际中发现文件头中很多信息都没有，比如文件大小。另外，扩展内容一般情况也是空的，所以基本上文件名后面就是文件内容。</p><table><thead><tr><th>offset</th><th>大小</th><th>意义</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>0x04034b50</td></tr><tr><td>26</td><td>2</td><td>文件名长度n</td></tr><tr><td>28</td><td>2</td><td>扩展内容长度m</td></tr><tr><td>30</td><td>n</td><td>文件名</td></tr><tr><td>30+n</td><td>m</td><td>扩展内容</td></tr><tr><td>30+n+m</td><td>不固定</td><td>文件内容</td></tr></tbody></table><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>找到核心目录开头</li><li>找出AndroidManifest.xml文件信息</li><li>找到在文件中对应的偏移</li><li>解压出AndroidManifest.xml</li><li>使用AXmlPrint2.jar转换xml</li></ol><p>比较难的是确认核心目录开头，我们可以先获取后1MB的内容，然后读取，如果没有匹配上manifest，则再向前取1MB的内容，再进行一次匹配。使用断点下载时同理。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>附上代码：这个代码是一边学习一边随手尝试写的，查找目录偏移，读取文件等有很多偷懒的写法，请自行优化。代码只是提供思路以及验证可行性，请不要在正式环境中使用。</p><p>另外注意，read()过后，计算下一个offset的时候，要去掉本身的大小的。比如：得到压缩后文件大小，再去获取文件名长度时，是20偏移 + 4字节再到28偏移，所以是skipBytes(4)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.util.zip.ZipEntry;</span><br><span class="line">import java.util.zip.ZipInputStream;</span><br><span class="line"></span><br><span class="line">public class ManifestGetter&#123;</span><br><span class="line"></span><br><span class="line">    public static final int DEFAULT_SIZE = 1024 * 1024 *2;</span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line"></span><br><span class="line">        byte[] signature = new byte[]&#123;0x50,0x4b,0x01,0x02&#125;;</span><br><span class="line">    </span><br><span class="line">        String filename = &quot;./test.apk&quot;;</span><br><span class="line">        File file = new File( filename);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            RandomAccessFile accessFile = new RandomAccessFile(file,&quot;r&quot;);</span><br><span class="line">            RandomAccessFile accessFile2 = new RandomAccessFile(file,&quot;r&quot;);</span><br><span class="line">            long offset = file.length() - DEFAULT_SIZE;</span><br><span class="line">            </span><br><span class="line">            accessFile.seek(offset);</span><br><span class="line">            </span><br><span class="line">            byte[] buffer = new byte[1024];</span><br><span class="line">            int len = 0;</span><br><span class="line">            while((len = accessFile.read(buffer) )&gt; 0)&#123;</span><br><span class="line">            </span><br><span class="line">                int index = 0;</span><br><span class="line">                for (; index &lt; len; index++) &#123;</span><br><span class="line">                    </span><br><span class="line">                    boolean flag = true;</span><br><span class="line"></span><br><span class="line">                    for (byte signatureB : signature) &#123;</span><br><span class="line"></span><br><span class="line">                        byte b = 0;</span><br><span class="line">                        if (index &lt; buffer.length - 4)&#123;</span><br><span class="line">                            b = buffer[index++];</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            b = (byte)accessFile.read();</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (signatureB != b)&#123;</span><br><span class="line">                            flag = false;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">//匹配到了0x02014b50标记</span><br><span class="line">                    if (flag)&#123;</span><br><span class="line"></span><br><span class="line">                        long subOffset = 0;</span><br><span class="line">                        if (index &lt; buffer.length - 4)&#123;</span><br><span class="line">                           subOffset = accessFile.getFilePointer() - buffer.length + index -4;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            subOffset = accessFile.getFilePointer();</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        //0x04034B50</span><br><span class="line">                        System.out.println(&quot;中心目录文件开始-----------&quot; + subOffset);</span><br><span class="line">                        System.out.println(&quot;offset =&quot; + subOffset);</span><br><span class="line">//压缩后文件大小 4字节</span><br><span class="line">                        accessFile2.seek(subOffset + 20);</span><br><span class="line">                        int fileSize = 0;</span><br><span class="line">                        for (int i =0; i &lt; 4; i++) &#123;</span><br><span class="line">                            fileSize += (accessFile2.read()&lt;&lt; (8 *i));</span><br><span class="line">                        &#125;    </span><br><span class="line">                        </span><br><span class="line">                        accessFile2.skipBytes(4);</span><br><span class="line">//文件名大小 2字节</span><br><span class="line">                        int size_byte1 = accessFile2.read();</span><br><span class="line">                        int size_byte2 = accessFile2.read();</span><br><span class="line"></span><br><span class="line">                        int name_size = (size_byte2 &lt;&lt; 8 ) + size_byte1;</span><br><span class="line">                        System.out.println(&quot;name size = &quot; + name_size);</span><br><span class="line">                        accessFile2.skipBytes(12);</span><br><span class="line"></span><br><span class="line">                        long fileOffset = 0;</span><br><span class="line"></span><br><span class="line">                        for (int i =0; i &lt; 4; i++) &#123;</span><br><span class="line">                            fileOffset += (accessFile2.read()&lt;&lt; (8 *i));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        byte[] nameBuf = new byte[name_size];</span><br><span class="line">                        accessFile2.read(nameBuf);</span><br><span class="line">                        String nameString = new String(nameBuf);</span><br><span class="line"></span><br><span class="line">                        System.out.println(nameString + &quot; offset = &quot;+ Long.toHexString(fileOffset));</span><br><span class="line"></span><br><span class="line">                        if (nameString.contains(&quot;AndroidManifest.xml&quot;))&#123;</span><br><span class="line">                           </span><br><span class="line">                            // file header</span><br><span class="line">                            accessFile2.seek(fileOffset);</span><br><span class="line"></span><br><span class="line">                            FileOutputStream out = new FileOutputStream(&quot;./dest.xml&quot;);</span><br><span class="line">                            // 文件里还有一个小文件头，这里加了1024字节，实际情况很小</span><br><span class="line">                            byte[] buf = new byte[fileSize + 1024];</span><br><span class="line">                            accessFile2.read(buf);</span><br><span class="line">                            ByteArrayInputStream bInputStream = new ByteArrayInputStream(buf);</span><br><span class="line">                            ZipInputStream zin = new ZipInputStream(bInputStream);</span><br><span class="line"></span><br><span class="line">                            ZipEntry zipEntry = zin.getNextEntry();</span><br><span class="line"></span><br><span class="line">                            System.out.println(zipEntry.getName() + &quot;文件信息在目录里，这里的size = &quot; + zipEntry.getSize());</span><br><span class="line">                            </span><br><span class="line">                            byte[] readBuf = new byte[fileSize + 1024];</span><br><span class="line"></span><br><span class="line">                            int readLength = 0;</span><br><span class="line">                            while ((readLength = zin.read(readBuf)) &gt; 0) &#123;</span><br><span class="line">                                byte[] bytes = new byte[readLength];</span><br><span class="line">                                System.arraycopy(readBuf, 0, bytes, 0, readLength);</span><br><span class="line">                                out.write(bytes);</span><br><span class="line">                                </span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            accessFile.close();</span><br><span class="line">                            accessFile2.close();</span><br><span class="line">                            out.close();</span><br><span class="line">                            return;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(nameString);</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">                    &#125;                   </span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">                offset += len;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            accessFile.close();</span><br><span class="line">            accessFile2.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;现有采集&quot;&gt;&lt;a href=&quot;#现有采集&quot; class=&quot;headerlink&quot; title=&quot;现有采集&quot;&gt;&lt;/a&gt;现有采集&lt;/h1&gt;&lt;p&gt;都知道APK就是一个zip包，目前，收集别人家的APK信息，原理都一样，一般都是先将APK文件下载，再提取AndroidManifest.xml，通过&lt;code&gt;AXmlPrint2.jar&lt;/code&gt;打开，得到反编译后的xml，解析xml得到包信息。&lt;/p&gt;
&lt;p&gt;那么，一个游戏好几个GB，真正用到的却只有几KB信息。如果能跳过内容，结合断点下载，直接下载到AndroidManifest.xml，那就能省很多流量了。&lt;/p&gt;
    
    </summary>
    
      <category term="android开发" scheme="http://www.lefo.me/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="android" scheme="http://www.lefo.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>升级targetSdkVersion为26以后</title>
    <link href="http://www.lefo.me/2019/07/02/target-sdk-26/"/>
    <id>http://www.lefo.me/2019/07/02/target-sdk-26/</id>
    <published>2019-07-02T21:02:00.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>google从下个月开始，所有在play上架的app都会要求升级的。为了与时俱进，我们的app也要升级到targetSdkVersion=26了，虽然我们的APP是助手类，不可能上架google play。</p><p>关于升级后8.0的各种介绍，参考这里<a href="https://developer.android.com/about/versions/oreo/" target="_blank" rel="noopener">https://developer.android.com/about/versions/oreo/</a></p><p>8.0行为变更看这里<a href="https://developer.android.com/about/versions/oreo/android-8.0-changes" target="_blank" rel="noopener">https://developer.android.com/about/versions/oreo/android-8.0-changes</a></p><p>基本上，看完上面链接里的内容以后，你就能针对你的代码做修改了。下面主要记录一下实际修改中的几处重点。</p><a id="more"></a><h1 id="后台限制"><a href="#后台限制" class="headerlink" title="后台限制"></a>后台限制</h1><p>官方介绍：<a href="https://developer.android.com/about/versions/oreo/background" target="_blank" rel="noopener">https://developer.android.com/about/versions/oreo/background</a></p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>如果改成了targetSdkVersion=26+，是不允许在后台启动service的。但是，要注意这里的后台两个字。google文档里已经讲的很清楚，当你的应用处于前台应用时，仍然可以使用startService。</p><p>所以，首先要做的是，把之前在Application中startService的代码删除掉，挪到activity的onCreate方法中。或者，在Application中，调用<a href="https://developer.android.com/reference/kotlin/android/app/Application?hl=en#registeractivitylifecyclecallbacks" target="_blank" rel="noopener">registerActivityLifecycleCallbacks</a>，在回调里startService。</p><p>当然，如果你的程序在运行时，有一个常驻通知，那么你可以将你的service变成一个前台service。此时，不能使用startService来启动，要使用startForegroundService，调用该方法就没有必须前台应用的限制了，任何地方都可以。但是，在startForegroundService开启一个service后，必须在5s内，调用它的startForeground()方法，将某个通知和其绑定起来，否则也会出错。</p><p>google也给了另外一种官方的后台任务实现方式，那就是使用<code>JobService</code>，关于用法网上一大堆，不再介绍，需要注意的是，这里要规范它的id。如果相同的id重复schedule，那么会先调用onStopJob再调用onStartJob。</p><p>如果之前是IntentService，那可以直接用JobIntentService，使用起来更简单。</p><p><a href="https://developer.android.com/reference/android/support/v4/app/JobIntentService" target="_blank" rel="noopener">JobIntentService</a></p><h3 id="附上官方demo"><a href="#附上官方demo" class="headerlink" title="附上官方demo"></a>附上官方demo</h3><p>官方DEMO:<a href="https://github.com/googlesamples/android-JobScheduler" target="_blank" rel="noopener">https://github.com/googlesamples/android-JobScheduler</a></p><h2 id="Receiver"><a href="#Receiver" class="headerlink" title="Receiver"></a>Receiver</h2><p>静态注册广播监听系统事件，失效了。关于广播的限制，官方文档里讲的也很清楚。我们要做的就是，把注册了一系列系统action的Receiver，再动态注册一次。比如常用的网络状态切换监听，之前只要写到manifest中就OK，现在必须手动调用一次register方法。还有我们项目中监听其它应用的安装卸载，一样需要动态注册。</p><p>registerReceiver()的文档中明确写到，你的Receiver是注册到Application中，我就直接将receiver注册到了application上。</p><blockquote><p>Context-registered receivers receive broadcasts as long as their registering context is valid. For an example, if you register within an <code>Activity</code> context, you receive broadcasts as long as the activity is not destroyed. If you register with the Application context, you receive broadcasts as long as the app is running.</p></blockquote><h1 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h1><p>Notification要求必须设置一个channel，否则是不予展示的。</p><p><a href="https://developer.android.com/training/notify-user/channels.html?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/training/notify-user/channels.html?hl=zh-cn</a></p><p>官方DEMO：<a href="https://github.com/googlesamples/android-Notifications" target="_blank" rel="noopener">https://github.com/googlesamples/android-Notifications</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT&gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">    NotificationChannelGroup group = new NotificationChannelGroup(GROUP_ID, GROUP_NAME);</span><br><span class="line">    manager.createNotificationChannelGroup(group);</span><br><span class="line">    NotificationChannel channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT);</span><br><span class="line">    channel.setGroup(GROUP_ID);</span><br><span class="line">    // ...</span><br><span class="line">    manager.createNotificationChannel(channel);</span><br><span class="line">    notification = new Notification.Builder(getApplicationContext(), CHANNEL_ID)</span><br><span class="line">            // ...</span><br><span class="line">            .build();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    notification = new NotificationCompat.Builder(getApplicationContext(), CHANNEL_ID)</span><br><span class="line">            // ...</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其它影响的地方"><a href="#其它影响的地方" class="headerlink" title="其它影响的地方"></a>其它影响的地方</h1><p>升级以后还是有不少影响需要注意：</p><ol><li>第三方SDK，像push sdk，大多使用了service，要在26以上支持，必须更新了。</li><li>权限问题，比如设置屏幕亮度，悬浮窗等。</li><li>API变更，比如getRunningService方法在api26以上就失效了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;google从下个月开始，所有在play上架的app都会要求升级的。为了与时俱进，我们的app也要升级到targetSdkVersion=26了，虽然我们的APP是助手类，不可能上架google play。&lt;/p&gt;
&lt;p&gt;关于升级后8.0的各种介绍，参考这里&lt;a href=&quot;https://developer.android.com/about/versions/oreo/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.android.com/about/versions/oreo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8.0行为变更看这里&lt;a href=&quot;https://developer.android.com/about/versions/oreo/android-8.0-changes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.android.com/about/versions/oreo/android-8.0-changes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基本上，看完上面链接里的内容以后，你就能针对你的代码做修改了。下面主要记录一下实际修改中的几处重点。&lt;/p&gt;
    
    </summary>
    
      <category term="android开发" scheme="http://www.lefo.me/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="android" scheme="http://www.lefo.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>垂直滚动的ViewPager存在滑动不灵敏的问题</title>
    <link href="http://www.lefo.me/2019/06/02/vertical-viewpager/"/>
    <id>http://www.lefo.me/2019/06/02/vertical-viewpager/</id>
    <published>2019-06-02T17:49:00.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垂直滚动的ViewPager"><a href="#垂直滚动的ViewPager" class="headerlink" title="垂直滚动的ViewPager"></a>垂直滚动的ViewPager</h1><p>凡是找到我这篇文章的，肯定都在网上看过这样一篇文章<code>[几行代码实现ViewPager垂直滚动]</code>，地址我就不上了，随便一搜，到处都是，原理也很简单，交换一下横竖坐标，再设置一个上下的<code>Transformer</code>。然而，事情并没有想像的那么简单。</p><a id="more"></a><h1 id="ViewPager滚动源码解析"><a href="#ViewPager滚动源码解析" class="headerlink" title="ViewPager滚动源码解析"></a>ViewPager滚动源码解析</h1><p>在我提交上面的交换xy坐标代码后，测试拿着手机过来找我了，出现的问题就是，必须慢慢的将当前页滑动过页面的一半，松手时，才能滚到上一页或者下一页。这就导致如果是大屏手机，用户会很难去到下一页。我本来是以为x y坐标的问题，跟踪源码后，发现并不是。</p><p>在ViewPager中，滚动到上一页或者下一页的关键方法叫<code>determineTargetPage</code>，其中，如果是滚动到下一页，currentPage是当前页的position，如果是滚动到上一页，currentPage是上一页的position。</p><p><img src="/image/20190602/viewpager-src.jpg" alt="image-20190602181111242"></p><p>第一个if的逻辑是，先计算滑动距离和滑动的速度，如果超过了<code>mFlingDistance</code>和<code>mMininumVelocity</code>，再根据速度的正负值来判断方向，如果velocity &gt; 0，则说明是[向右滑]的手势（先不考虑更换xy坐标），也就是滑动到上一页，返回currentPage。(currentPage是上一页的position)。如果velocity &lt; 0，那就是[向左滑]的手势（先不考虑更换xy坐标），则是去到下一页。(currentPage是当前页的position)</p><p>else中的逻辑是，当用户慢慢拖动后松开手，也就是滚动速度和滚动距离的条件没有同时满足。此时通过计算出的<code>truncator</code>来计算目标页，可以理解为<code>pageOffset</code>是<code>currentPage</code>进了屏幕多少多少，而truncator就是剩下多少时滑动的一个比例。举个例子：</p><p>假如我们向下滑，上一页只露出了40%，那么pageOffset就是0.6，此时，0.6+0.6取整就是1，targetPage = currentPage + 1，而因为此时currentPage是上一页，所以又回滚回去。同理，假如我们向上滑，currentPage是当前页，也需要把pageOffSet滑动到0.6的位置，才能到下一页。</p><h1 id="修改速率不成功"><a href="#修改速率不成功" class="headerlink" title="修改速率不成功"></a>修改速率不成功</h1><p>找到了原理，就要修改了，起初我想着是，修改<code>mFlingDistance</code>和<code>mMininumVelocity</code>这两个值就好，因为这俩变量本身不支持修改，就把ViewPager的源码拷贝了一份。满心欢喜的做了个测试，失败，失败的原因，也比较蹊跷。</p><p>MotionEvent有一个方法，叫setLocation，交换xy坐标的方法，正是采用调用该方法实现的。但是在viewPager中，通过调用VelocityTracker的getXVelocity方法时，不论你如何执行setLocation，最终计算出的velocity永远都是指着真正在屏幕X方向上滑动的速度，也就是此时并没有把y轴的速度转到x上。这部分应该是跟native内部实现有关。</p><h1 id="去掉速度，只判断距离"><a href="#去掉速度，只判断距离" class="headerlink" title="去掉速度，只判断距离"></a>去掉速度，只判断距离</h1><p>既然速度废了，那就不判断速率了，只判断距离。于是代码被我改成了这样子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">determineTargetPage</span><span class="params">(<span class="keyword">int</span> currentPage, <span class="keyword">float</span> pageOffset, <span class="keyword">int</span> velocity, <span class="keyword">int</span> deltaX)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> targetPage;</span><br><span class="line">       <span class="keyword">if</span> (Math.abs(deltaX) &gt; mFlingDistance) &#123;</span><br><span class="line">           targetPage = velocity &gt; <span class="number">0</span> ? currentPage : currentPage + <span class="number">1</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">float</span> truncator = currentPage &gt;= mCurItem ? <span class="number">0.9f</span> : <span class="number">0.1f</span>;</span><br><span class="line">           targetPage = currentPage + (<span class="keyword">int</span>) (pageOffset + truncator);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mItems.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> ItemInfo firstItem = mItems.get(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">final</span> ItemInfo lastItem = mItems.get(mItems.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Only let the user target pages we have items for</span></span><br><span class="line">          targetPage = Math.max(firstItem.position, Math.min(targetPage, lastItem.position));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> targetPage;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此时，只判断了<code>mFlingDistance</code>，为了保险起见，我又将else中的代码，计算truncator时，改成了0.8和0.2。也就是当上一页或者下一页露出10%以上时，则滚动到相应的页面。代码是周末前提交的，写这篇博客是在周末，暂没有产品和测试的体验结果。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>复制ViewPager.java的时候，PagerAdapter有一个方法是setViewPagerObserver，因为这个方法是不允许访问的，这里可以改成registerDataSetObserver和unregisterDataSetObserver</p><p>google已经出了viewpager2了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;垂直滚动的ViewPager&quot;&gt;&lt;a href=&quot;#垂直滚动的ViewPager&quot; class=&quot;headerlink&quot; title=&quot;垂直滚动的ViewPager&quot;&gt;&lt;/a&gt;垂直滚动的ViewPager&lt;/h1&gt;&lt;p&gt;凡是找到我这篇文章的，肯定都在网上看过这样一篇文章&lt;code&gt;[几行代码实现ViewPager垂直滚动]&lt;/code&gt;，地址我就不上了，随便一搜，到处都是，原理也很简单，交换一下横竖坐标，再设置一个上下的&lt;code&gt;Transformer&lt;/code&gt;。然而，事情并没有想像的那么简单。&lt;/p&gt;
    
    </summary>
    
      <category term="android开发" scheme="http://www.lefo.me/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="android" scheme="http://www.lefo.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>使用jenkins为android工程打包，支持多包名，改资源（踩坑指南）</title>
    <link href="http://www.lefo.me/2019/03/29/jenkins-android-2/"/>
    <id>http://www.lefo.me/2019/03/29/jenkins-android-2/</id>
    <published>2019-03-29T13:30:00.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>上一篇文章主要写了打包刚开始的配置和参数化构建。这篇文章主要讲一讲在改包名、改资源的打包实践中，常会碰到的问题以及解决办法。如果看博客的人有更好的解决办法，也可以找我交流，关于页面有我联系方式。</p><p>打包的主要需求如下：</p><ol><li>改包名</li><li>可以替换icon，可以修改应用名，包括应用内部显示的名称（如版权信息）</li><li>可以控制部分功能是否开启</li></ol><h1 id="改包名分析"><a href="#改包名分析" class="headerlink" title="改包名分析"></a>改包名分析</h1><p>我们知道，改包名只是修改applicationId，和代码中类的package无关，所以基本上代码和AndroidManifest.xml中组件的name，都是不需要改动的。但是还是会涉及到下面的这些问题：</p><a id="more"></a><ol><li>代码中使用”包名”写死的路径，比如<code>/data/data/com.xx.xx/</code>。</li><li>AndroidManifest.xml中，ContentProvider会填一个<code>authorities</code>属性，换包名等于换应用<code>authorities</code>就得跟着变。部分<code>action</code>，部分activity的<code>taskAffinity</code>。</li><li>第三方的client_key(支持多包名就没关系了，比如umeng push)。</li><li>提供给外部调用的activity和service，偶尔会要求必须在包名路径下(刚好我碰上了这奇葩事)。</li></ol><p>具体解决办法：</p><ol><li>使用全局查找，找出包名的字符串，统一改为context.getPackageName()，没有context对象的地方，使用<code>BuildConfig.APPLICATION_ID</code>。</li><li>当我们配了applicationId以后，就可以在AndroidMenifest.xml中使用<code>{$applicationId}</code>代替写死的包名。</li><li>像<code>applicationId</code>一样，在gradle文件的<code>defaultConfig</code>中，把每个key都声明成常量调用。在做打包之前，我想的是给产品运营人员提供一个构建参数让他们填写，后来意识到，其实这些clientkey和包名是绑定的，于是在工程里新建了一个名包文件夹，里面保存了key=value的格式，打包时，通过shell读取到环境变量，然后用shell修改gradle的配置。</li><li>actiivity可以使用<code>activity-alias</code>标签<code>&lt;activity-alias android:name=&quot;{$applicationId}.XActivity&quot; android:targetActivity=&quot;&quot;</code>，至于service，就比较难搞，我这里的解决办法是，给当前包名写了个继承原包名Service的空子类，修改AndroidManifest.xml中的name使用<code>${applicationId}</code>。然后代码中，给如果有startService的地方，就使用<code>Class.forName(BuildConfig.APPLICATION_ID + &quot;.XService&quot;)</code>反射。</li></ol><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><strong>因为这里的脚本过于繁琐，从这里开始，请大家放弃看这一篇，直接去这里[<a href="2020/09/04/jenkins-android-3/">使用jenkins为android工程打包，支持多包名，改资源（优化方案）</a></strong></p><p>部分shell脚本的源码，这里只是修改build.gradle的脚本，要打包还要再加入<code>./gradlew assembleRelease</code>等其它个性化脚本<br>将完整的shell脚本保存成sh文件，放到工程目录下，在jenkins中执行该sh文件<code>sh ./jenkinsbuild.sh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">field_name=(&apos;BOOL_FIELD1&apos; )</span><br><span class="line">value=($BOOL_FIELD1 )</span><br><span class="line">#注意 这里是用测试的值 注意value要和filed的name对应 在shell中全是字符串格式</span><br><span class="line">#value=(&apos;false&apos; &apos;false&apos; &apos;false&apos; &apos;false&apos; &apos;false&apos; &apos;false&apos; &apos;false&apos; &apos;false&apos; &apos;false&apos; &apos;false&apos;)</span><br><span class="line"></span><br><span class="line">for i in &quot;$&#123;!field_name[@]&#125;&quot;;</span><br><span class="line">do</span><br><span class="line">    echo $&#123;field_name[$i]&#125; $&#123;value[$i]&#125;</span><br><span class="line">    #只有当变量不为null的情况下，才去修改Build文件</span><br><span class="line">    if [ -n &quot;$&#123;value[$i]&#125;&quot; ];then</span><br><span class="line">        toReplace=&apos;buildConfigField &quot;boolean&quot;, \&quot;&apos;$&#123;field_name[$i]&#125;&apos;\&quot;, &quot;&apos;$&#123;value[$i]&#125;&apos;&quot;&apos;</span><br><span class="line">        echo $toReplace</span><br><span class="line">        sed -i &apos;s/buildConfigField \&quot;boolean\&quot;, \&quot;&apos;&quot;$&#123;field_name[$i]&#125;&quot;&apos;\&quot;, \&quot;\([a-zA-Z]*\)\&quot;/&apos;&quot;$toReplace&quot;&apos;/g&apos; build.gradle</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">toReplace=&apos;applicationId \&quot;&apos;$PACKAGE_NAME&apos;\&quot;&apos;</span><br><span class="line">echo $toReplace</span><br><span class="line">sed -i &apos;s/applicationId \&quot;com.lefo.oldpkg\&quot;/&apos;&quot;$toReplace&quot;&apos;/g&apos; build.gradle</span><br><span class="line"></span><br><span class="line">#字符串变量  操作方式是删除掉gradle文件中旧的  添加新的</span><br><span class="line">field_name=(&apos;PT_CLIENT_ID&apos; &apos;PT_CLIENT_SECRET&apos; &apos;PT_QQ_ID&apos; &apos;PT_WX_RELEASE_ID&apos; &apos;BUGLY_ID&apos; &apos;APP_TYPE&apos; &apos;PT_SERVER_SECRET&apos; &apos;LICENSE_URL&apos; &apos;POLICY_URL&apos;)</span><br><span class="line">value_name=(&apos;client_id&apos; &apos;client_secret&apos; &apos;qq_id&apos; &apos;wx_id&apos; &apos;bugly_id&apos; &apos;app_type&apos; &apos;server_secret&apos; &apos;license&apos; &apos;policy&apos;)</span><br><span class="line"></span><br><span class="line">for i in &quot;$&#123;!field_name[@]&#125;&quot;;</span><br><span class="line">do</span><br><span class="line">    echo $&#123;field_name[$i]&#125;</span><br><span class="line">    value=$&#123;value_name[$i]&#125;</span><br><span class="line">toReplace=&apos;buildConfigField \&quot;String\&quot;, \&quot;&apos;$&#123;field_name[$i]&#125;&apos;\&quot;, \&quot;\\\&quot;&apos;$&#123;!value&#125;&apos;\\\&quot;\&quot;&apos;</span><br><span class="line">echo $toReplace</span><br><span class="line">sed -i &apos;/buildConfigField \&quot;String\&quot;, \&quot;&apos;$&#123;field_name[$i]&#125;&apos;\&quot;, /d&apos; build.gradle</span><br><span class="line">sed -i &apos;/defaultConfig/a buildConfigField \&quot;String\&quot;, \&quot;&apos;$&#123;field_name[$i]&#125;&apos;\&quot;, \&quot;\\\&quot;&apos;$&#123;!value&#125;&apos;\\\&quot;\&quot;&apos; build.gradle</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>那么，脚本中，<code>client_id</code>这些，是如何一次性加入到环境变量中的？这里要用到另一款插件，<strong>Environment Injector Plugin</strong>。这款插件可以在执行时往执行环境中注入变量。关于变量的配置信息，我在工程目录下新建了一个文件夹保存的配置文件。就是key=value的格式，就是你熟悉的java properties file。这里的<code>PACKAGE_NAME</code>，在jenkins参数化构建时，给产品提供的是一个选项列表，固定好包名列表给产品选择选，毕竟涉及到client_key的修改，不能随便填。<br><img src="/image/20190329/key-config.jpg" alt></p><h1 id="改资源该怎么改"><a href="#改资源该怎么改" class="headerlink" title="改资源该怎么改"></a>改资源该怎么改</h1><p>产品居然想要修改APP名称，图标，部分页面的图片，这里要用到gradle配置中的productFlavors。工程中新建一个文件夹<code>lefo</code>，注意要名字对应，然后我们将要替换的资源，按原资源存放位置，放到package1目录下，打包时，不能再执行assembleRelease，这个时候就应该是<code>./gradlew assembleLefoRelease</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">productFlavors&#123;</span><br><span class="line">lefo&#123;</span><br><span class="line">    //产品说，可不可以做到应用显示的名字和内部的名字不一样  可以 给应用单独配一个名字 本来有个资源叫app_name</span><br><span class="line">    manifestPlaceholders = [label:&quot;@string/app_label&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>既然想这么定制，那就彻底交给产品，他们想放什么放什么。</p><p>修改应用名称：直接使用jenkins中参数配置，通过sed命令修改strings.xml<br>图标资源替换：最初想的是从某处下载一份资源，然后替换掉包中资源，产品那边和我们一样用的是svn，jenkins在构建的时候，SCM是在构建之前的，也就是说，在构建以前就要checkout代码。问题就来了，资源目录的URL可以做为一个参数传进来，但并不是每一次打包，都需要替换资源。如果URL没有传，那SCM就不能过，构建就会失败，根本走不到编译过程。这里同样要使用插件<strong>Environment Injector Plugin</strong>，它可以在SCM以前，使用脚本修改某个变量的值。</p><p>注意下图中我使用的是<code>groovy script</code>，如果我没有记错的话，只有<code>groovy script</code>是可以在SCM之前执行的。如果没有填，脚本就给它一个内容为空的文件夹路径，SCM配置中，支持<code>${RES_URL}</code>使用。为什么不给<code>RES_URL</code>配一个默认值呢？因为不填写更直观，产品修改的时候，也不用每次都删除旧的再复制上新的还得检查一遍。</p><p><img src="/image/20190329/res-url.jpg" alt></p><h1 id="续"><a href="#续" class="headerlink" title="续"></a>续</h1><p>产品经理用的很嗨，暂时没有续，为了不涉及隐私，整篇加上前一篇都是一些片段，想直接copy进去使用的可能要失望了。不过，拼凑一起还是可以的，实在不懂的来找我。</p><p><strong>写了一篇最新的介绍，打包脚本更简洁，大家可以结合着看[<a href="2020/09/04/jenkins-android-3/">使用jenkins为android工程打包，支持多包名，改资源（优化方案）</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;p&gt;上一篇文章主要写了打包刚开始的配置和参数化构建。这篇文章主要讲一讲在改包名、改资源的打包实践中，常会碰到的问题以及解决办法。如果看博客的人有更好的解决办法，也可以找我交流，关于页面有我联系方式。&lt;/p&gt;
&lt;p&gt;打包的主要需求如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;改包名&lt;/li&gt;
&lt;li&gt;可以替换icon，可以修改应用名，包括应用内部显示的名称（如版权信息）&lt;/li&gt;
&lt;li&gt;可以控制部分功能是否开启&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;改包名分析&quot;&gt;&lt;a href=&quot;#改包名分析&quot; class=&quot;headerlink&quot; title=&quot;改包名分析&quot;&gt;&lt;/a&gt;改包名分析&lt;/h1&gt;&lt;p&gt;我们知道，改包名只是修改applicationId，和代码中类的package无关，所以基本上代码和AndroidManifest.xml中组件的name，都是不需要改动的。但是还是会涉及到下面的这些问题：&lt;/p&gt;
    
    </summary>
    
      <category term="android打包" scheme="http://www.lefo.me/categories/android%E6%89%93%E5%8C%85/"/>
    
    
      <category term="android" scheme="http://www.lefo.me/tags/android/"/>
    
      <category term="jenkins" scheme="http://www.lefo.me/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>使用jenkins为android工程打包，支持多包名，改资源（简单上手）</title>
    <link href="http://www.lefo.me/2019/03/26/jenkins-android-1/"/>
    <id>http://www.lefo.me/2019/03/26/jenkins-android-1/</id>
    <published>2019-03-26T14:44:00.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载安装jenkins"><a href="#下载安装jenkins" class="headerlink" title="下载安装jenkins"></a>下载安装jenkins</h1><p>官网地址：<a href="https://jenkins.io/" target="_blank" rel="noopener">https://jenkins.io/</a><br>没什么好说的，网上教程一大堆，唯一要做的是要修改jenkins_home目录所在分区，因为将来所有的内容都要放在这里，如果分区太小，指不定哪天就满了，到时就打不了包了。</p><p>实践中，发现/home/jenkins目录也要处理一下，我就碰上了/home/jenkins目录占满了根分区，打开发现都是gradle打包时生成的一些缓存，就将/home/jenkins使用<code>ln</code>命令做了个软连接到另一个分区目录下。</p><a id="more"></a><h1 id="新建jenkins项目"><a href="#新建jenkins项目" class="headerlink" title="新建jenkins项目"></a>新建jenkins项目</h1><p><img src="/image/20190326/create-jenkins.jpg" alt="创建项目"><br><img src="/image/20190326/source.jpg" alt="代码库"></p><p>选择<code>新建任务</code>,填一个名字，选择自由风格的项目，点下方OK<br>进入配置页，源码管理里选择你们所用的源码管理工具，填入地址，用户名认证信息等。<br>注意，这里可能没有git和svn，那么需要你去系统管理，管理插件模块，搜索git或者svn插件并安装。后续还有其它功能需要安装插件。</p><p>构建步骤 选择 Execute shell，Command里填入<code>./gradlew assembleRelease</code>就好了。</p><h1 id="改渠道号、版本号打包"><a href="#改渠道号、版本号打包" class="headerlink" title="改渠道号、版本号打包"></a>改渠道号、版本号打包</h1><p>我们搭建jenkins，肯定不只是简单的打个包。一般常见的需求有，打渠道包，改包名，改资源文件。</p><h2 id="参数化打包，打包时修改渠道号，版本号"><a href="#参数化打包，打包时修改渠道号，版本号" class="headerlink" title="参数化打包，打包时修改渠道号，版本号"></a>参数化打包，打包时修改渠道号，版本号</h2><p>jenkins提供了一个功能叫<code>参数化构建</code>，打包时，可以手动配一些参数。在<code>配置</code>中勾选<code>参数化构建过程</code>，下面添加你需要的参数，支持布尔型，字符串型。这些添加的参数，在shell中可以直接使用${参数名}使用，比如我们可以填入渠道号，versionname，versioncode等，如果你想填APP的名称也可以。</p><p>参数填了，如何在打包时配到gradle文件中呢？</p><p><strong>因为这里的脚本过于繁琐，请大家不要使用sed修改这种方案，直接去这里[<a href="2020/09/04/jenkins-android-3/">使用jenkins为android工程打包，支持多包名，改资源（优化方案）</a></strong></p><p>使用<code>sed</code>命令开修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#echo get versioncode</span><br><span class="line">vc=$VERSION_CODE;</span><br><span class="line">sed -i &apos;s/android:versionCode=\&quot;\([a-zA-Z0-9.]*\)\&quot;/android:versionCode=\&quot;&apos;$vc&apos;\&quot;/g&apos;  AndroidManifest.xml</span><br><span class="line">echo &quot;version code : $vc&quot;</span><br><span class="line"></span><br><span class="line">#echo get  versionname</span><br><span class="line">vn=$VERSION_NAME</span><br><span class="line">sed -i &apos;s/android:versionName=\&quot;\([a-zA-Z0-9.]*\)\&quot;/android:versionName=\&quot;&apos;$vn&apos;\&quot;/g&apos;  AndroidManifest.xml</span><br><span class="line">echo &quot;version name : $vn&quot;</span><br><span class="line"></span><br><span class="line">./gradlew assembleRelease</span><br></pre></td></tr></table></figure><p>其中，VERSION_CODE和VERSION_NAME就是在jenkins中配置的参数，我这里是改的manifest文件，我们也可以用sed命令修改gradle文件。</p><h2 id="改包名"><a href="#改包名" class="headerlink" title="改包名"></a>改包名</h2><p>通过sed命令修改gradle文件中的<code>build applicationId packagename</code>，首先在参数化构建中，添加一个名称为PACKAGE_NAME的变量，供打包的人填写包名。然后在构建shell前面加入下列shell脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toReplace=&apos;applicationId \&quot;&apos;$PACKAGE_NAME&apos;\&quot;&apos;</span><br><span class="line">echo $toReplace</span><br><span class="line">sed -i &apos;s/applicationId \&quot;com.old.pkgname\&quot;/&apos;&quot;$toReplace&quot;&apos;/g&apos; build.gradle</span><br></pre></td></tr></table></figure><h2 id="修改构建后生成的名称"><a href="#修改构建后生成的名称" class="headerlink" title="修改构建后生成的名称"></a>修改构建后生成的名称</h2><p>通常jenkins打包完成后，左侧的构建历史，是一个数字序号，时间一长可能就忘了对应关系，所以一般情况需要将名称修改成可读的格式，那么如何在构建时，自动就修改好名称？</p><p>使用插件<code>Version Number</code>，安装该插件后，去到项目配置页，在构建环境下，勾选<code>Create a formatted version number</code>，再在下面的<code>Build Display Name</code>选项勾选<code>Build Display Name</code></p><p>在<code>Environment Variable Name</code>中可以将生成的名称赋值给一个变量名，在后续构建时的shell中可以使用，根据自己喜好起一个就行。</p><p>在<code>Version Number Format String</code>中可以填写想要生成的名称格式，可以使用<code>${变量名}</code>引用环境变量和参数名称，同时点右侧的问号可以看到系统提供的一部分时间相关的变量名。</p><p>如：<code>${VERSION_CODE}_${VERSION_NAME}_${BUILD_ID}</code></p><p><img src="/image/20190326/formatted-version-number.jpg" alt="构建名称"></p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>以上讲的就是基本打包流程，但是实际应用中，还存在一些问题，比如，改了包名后，一些第三方的client key也要修改。再加上产品的对资源、功能定制需求也越来越复杂，上面的方式是绝对难满足他们定制化的要求的。下篇见。。。</p><p>下篇博客写在打包实际应用中，是如何通过jenkins改包名和改资源，以及解决一些随包名存在的问题和注意事项。</p><p><strong>写了一篇最新的介绍，打包脚本更简洁，大家可以结合着看[<a href="2020/09/04/jenkins-android-3/">使用jenkins为android工程打包，支持多包名，改资源（优化方案）</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;下载安装jenkins&quot;&gt;&lt;a href=&quot;#下载安装jenkins&quot; class=&quot;headerlink&quot; title=&quot;下载安装jenkins&quot;&gt;&lt;/a&gt;下载安装jenkins&lt;/h1&gt;&lt;p&gt;官网地址：&lt;a href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jenkins.io/&lt;/a&gt;&lt;br&gt;没什么好说的，网上教程一大堆，唯一要做的是要修改jenkins_home目录所在分区，因为将来所有的内容都要放在这里，如果分区太小，指不定哪天就满了，到时就打不了包了。&lt;/p&gt;
&lt;p&gt;实践中，发现/home/jenkins目录也要处理一下，我就碰上了/home/jenkins目录占满了根分区，打开发现都是gradle打包时生成的一些缓存，就将/home/jenkins使用&lt;code&gt;ln&lt;/code&gt;命令做了个软连接到另一个分区目录下。&lt;/p&gt;
    
    </summary>
    
      <category term="android打包" scheme="http://www.lefo.me/categories/android%E6%89%93%E5%8C%85/"/>
    
    
      <category term="android" scheme="http://www.lefo.me/tags/android/"/>
    
      <category term="jenkins" scheme="http://www.lefo.me/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Mac系统的TM快照占了空间导致iTunes不能备份手机</title>
    <link href="http://www.lefo.me/2018/10/13/apple-itunes-volume/"/>
    <id>http://www.lefo.me/2018/10/13/apple-itunes-volume/</id>
    <published>2018-10-13T21:57:00.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac系统的TM快照占了空间导致iTunes不能备份手机"><a href="#Mac系统的TM快照占了空间导致iTunes不能备份手机" class="headerlink" title="Mac系统的TM快照占了空间导致iTunes不能备份手机"></a>Mac系统的TM快照占了空间导致iTunes不能备份手机</h1><p>国庆的时候，我的手机被我女票一脚踢掉了2300块，屏幕黑了一个角，iPhone X, OLED屏幕。</p><p>本来约到了今天天才吧维修，3点多的时候，打算给手机备个份，就接上线开工了。结果提示空间不足。</p><p>我电脑是256GB的MAC，剩余还有170GB，手机也是256GB，使用了有106GB</p><p>电脑上打开关于本机，显示剩余170GB，但是用自带的磁盘工具，就显示剩余20GB</p><p>在网上查了查资料，都是说time machine的快照占了空间，就把备份关了，空间还是没有释放。</p><p>搞不定，打支持电话，结果客服姐姐给我远程指导了一番没有成功，然后让我等一下查一查，过一会一本正经的和我说说：备份不是只备份数据的，256GB的电脑是备不了256的手机的，建议您换一个大容量的电脑。</p><p>WTF？？？难道是因为我穷？</p><p>挂了电话，自己继续研究，找到了命令行，在命令行下删除了。</p><p>sudo tmutil listsnapshots /<br>sudo tmutil deletesnapshots</p><p>继续备份，成功了。</p><p>然后时间赶不上了，好不容易抢到的天才吧，又得推迟了，而且明天已经没有了，约了下周的。</p><p>时间机器的本地快照：<br><a href="https://support.apple.com/zh-cn/HT204015" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT204015</a></p><p>苹果还号称这个有多屌，说什么用到磁盘的时候，自己就删除了。结果和自家的软件还起了冲突，我关了自动备份重启了5回，都没有删除掉我的快照腾出空间。</p><p>另外，主要是因为穷。谁给我点钱我换个512GB的MAC，512应该够了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac系统的TM快照占了空间导致iTunes不能备份手机&quot;&gt;&lt;a href=&quot;#Mac系统的TM快照占了空间导致iTunes不能备份手机&quot; class=&quot;headerlink&quot; title=&quot;Mac系统的TM快照占了空间导致iTunes不能备份手机&quot;&gt;&lt;/a&gt;Ma
      
    
    </summary>
    
      <category term="apple" scheme="http://www.lefo.me/categories/apple/"/>
    
    
  </entry>
  
  <entry>
    <title>ListView实现仿知乎广告Item</title>
    <link href="http://www.lefo.me/2017/08/27/listview-hollow-item/"/>
    <id>http://www.lefo.me/2017/08/27/listview-hollow-item/</id>
    <published>2017-08-27T16:45:39.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>知乎APP有一个广告效果，是list在滑动的时候，在某一个item显示出一个远大于item的背景，给人一种item是空的感觉，网上已经有了demo，但我看了看全是拿RecyclerView写的，RecyclerView有一个好处就是，它滑动时的回调，可以准确的拿到dx dy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void onScrolled(RecyclerView recyclerView, int dx, int dy)</span><br></pre></td></tr></table></figure><p>但是结合我们的项目，还是使用的之前的ListView，如果整个修改成RecyclerView，成本太高，于是就在ListView上尝试的写了一次，稍微记录一下实现方法。</p><p>因为我们的Item里面，还有一个类似弹幕的东东，就没有像网上的demo一样直接画drawable，而是采用了LinearLayout来实现。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ListView也有onScroll()方法，不它该方法的回调时给的参数是item的position</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount)</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>整个item的布局比较简单，使用的是指定高度的FrameLayout，其内部再嵌套一个和ListView高度一样的LinearLayout（这里可以在adapter的getView中拿到ListView的高度），在onScroll方法中，对visibleItem进行遍历，凡是碰到是这种item的。</p><p>拿到该类型的item的view后，获取top bottom，就是当前view相对于父控件的度坐标，相当于拿到了RecyclerView中onScroll()的dx，dy。</p><p>根据top，bottom计算LinearLayout需要的偏移。因为在FrameLayout中，LinearLayout是在Item顶部对齐的，所以，这里需要调用LinearLayout的scrollTo(0,top)方法，将你的FrameLayout内部嵌套的LinearLayout滚动到top的位置。</p><h1 id="放点伪代码"><a href="#放点伪代码" class="headerlink" title="放点伪代码"></a>放点伪代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123;</span><br><span class="line">    final int height = view.getHeight();</span><br><span class="line">    final int width = view.getWidth();</span><br><span class="line">    if (view instanceOf HollowView)&#123;</span><br><span class="line">HollowView itemView = (HollowView) view.getChildAt(i - firstVisibleItem);</span><br><span class="line">final int top = itemView.getTop();</span><br><span class="line">int bottom = itemView.getBottom();</span><br><span class="line">itemView.update(width,height, top, bottom);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>我们还有其它一些动画，都是item里面的view需要跟着滑动来像弹幕一样移动，到达一定位置后，缩小，放大。</p><p>只要在update里面，setX  setScaleX setScaleY，写具体的方法就OK。初中学的知识，y=kx+b<br>b是初始化时的偏移，k就是速度了。x变量就是top的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;知乎APP有一个广告效果，是list在滑动的时候，在某一个item显示出一个远大于item的背景，给人一种item是空的感觉，网上已经有了demo，但我看了看全是拿RecyclerView写的，RecyclerView有一个好处就是，它滑动时的回调，可以准确的拿到dx dy。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void onScrolled(RecyclerView recyclerView, int dx, int dy)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是结合我们的项目，还是使用的之前的ListView，如果整个修改成RecyclerView，成本太高，于是就在ListView上尝试的写了一次，稍微记录一下实现方法。&lt;/p&gt;
&lt;p&gt;因为我们的Item里面，还有一个类似弹幕的东东，就没有像网上的demo一样直接画drawable，而是采用了LinearLayout来实现。&lt;/p&gt;
&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;ListView也有onScroll()方法，不它该方法的回调时给的参数是item的position&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="android开发" scheme="http://www.lefo.me/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>是否允许创建快捷方式的权限检测</title>
    <link href="http://www.lefo.me/2017/05/19/shortcut-permission/"/>
    <id>http://www.lefo.me/2017/05/19/shortcut-permission/</id>
    <published>2017-05-19T15:02:50.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>部分手机的权限管理里，会有一个创建快捷方式权限。近期，产品妹子发现360手机助手可以检测到权限并弹出引导提示，符合的机型有，小米，VIVO，华为。于是我们也得加啊。。。</p><h1 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h1><h2 id="MIUI"><a href="#MIUI" class="headerlink" title="MIUI:"></a>MIUI:</h2><p>小米手机root方便，root后，直接看到了权限管理的配置的值，小米上，通过AppOpsManager的checkOpNoThrow()可以检测到是否有快捷方式权限。至于op的值是多少，我就不写了，自己查一查。</p><h2 id="vivo"><a href="#vivo" class="headerlink" title="vivo"></a>vivo</h2><p>找到了vivo的launcher的所有快捷方式所在的ContentProvider，<code>content://com.bbk.launcher2.settings/favorites</code>遍历了一圈发现了一个字段叫<code>shortcutPermission</code>，修改了权限后，这个值会有变化。</p><p>有趣的是，初始化假如是禁止的情况，它的值是1，但是只要编辑过，就会变化成16（允许），17（禁止），18（询问，部分手机有这个选项）。</p><a id="more"></a><h2 id="EMUI"><a href="#EMUI" class="headerlink" title="EMUI"></a>EMUI</h2><p>最坑的是EMUI，用尽各种招数，都没有搞到到底是如何检测的权限。因为发现，在权限为询问的时候，创建快捷方式时，360助手会弹出两次系统询问的弹窗，而只在第一次点禁止时，APP才弹出提示。如果第一次点了允许，第二次不管点了禁止还是允许，都会记为已经创建过。</p><p>起先，怀疑是监听了快捷方式创建的广播，后来发现，如果是监听的快捷方式的广播，点禁止后，不能知道是点了禁止，需要用handler调用sendMessageDelayed()，而在receiver收到广播后，再removeMessage。这种方法导致的结果就是delay的时间不可控，另外，其实也不需要弹出两次权限询问的弹窗。</p><p>思考后，打算从sendBroadcast()方法入手，看看sendBroadcast到底做了什么操作，想到了用<code>traceview</code>，果然有如下发现。</p><p><img src="/image/20170519/huawei-permission.jpg" alt></p><p>图片中，可以看出它调用了一个<code>HwSystemManager.canSendBroadcast(Context context,Intent intent)</code></p><p>最终定位到<br><code>com.huawei.hsm.permission.PermissionManager.canSendBroadcast(Context context,Intent intent)</code></p><p>利用反射，发现该方法返回了boolean类型，允许就是可以true，禁止就是false。而且，如果是询问，该方法会弹出权限询问弹窗，阻塞你的APP的主线程，用户点了禁止或者允许，再接着往下执行，相当好用。</p><p>代码我就不上了，该写的点都写了，实在需要的可以走点 关于 找到我。</p><h2 id="OPPO"><a href="#OPPO" class="headerlink" title="OPPO"></a>OPPO</h2><p>oppo是另一个哥们自己找到的方法，我这里就直接贴出来，感谢大哥。反馈说android 10上也可以使用。具体返回的内容，还请自己测试一下哦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static int b(Context context, String pkg) &#123;</span><br><span class="line">        ContentResolver contentResolver = context.getContentResolver();</span><br><span class="line">        if (contentResolver == null) return 2;</span><br><span class="line">        try &#123;</span><br><span class="line">            Uri parse = Uri.parse(&quot;content:/settings/secure/launcher_shortcut_permission_settings&quot;);</span><br><span class="line">            Cursor query = contentResolver.query(parse, null, null, null, null);</span><br><span class="line">            if (query == null) return 2;</span><br><span class="line">            while (query.moveToNext()) &#123;</span><br><span class="line">                String string = query.getString(query.getColumnIndex(&quot;value&quot;));</span><br><span class="line">                if (!TextUtils.isEmpty(string)) &#123;</span><br><span class="line">                    if (string.contains(pkg + &quot;, 1&quot;)) &#123;</span><br><span class="line">                        return 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (string.contains(pkg + &quot;, 0&quot;)) &#123;</span><br><span class="line">                        return 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            query.close();</span><br><span class="line">            return 2;</span><br><span class="line">        &#125; catch (Throwable th) &#123;</span><br><span class="line">            th.printStackTrace();</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;部分手机的权限管理里，会有一个创建快捷方式权限。近期，产品妹子发现360手机助手可以检测到权限并弹出引导提示，符合的机型有，小米，VIVO，华为。于是我们也得加啊。。。&lt;/p&gt;
&lt;h1 id=&quot;调研&quot;&gt;&lt;a href=&quot;#调研&quot; class=&quot;headerlink&quot; title=&quot;调研&quot;&gt;&lt;/a&gt;调研&lt;/h1&gt;&lt;h2 id=&quot;MIUI&quot;&gt;&lt;a href=&quot;#MIUI&quot; class=&quot;headerlink&quot; title=&quot;MIUI:&quot;&gt;&lt;/a&gt;MIUI:&lt;/h2&gt;&lt;p&gt;小米手机root方便，root后，直接看到了权限管理的配置的值，小米上，通过AppOpsManager的checkOpNoThrow()可以检测到是否有快捷方式权限。至于op的值是多少，我就不写了，自己查一查。&lt;/p&gt;
&lt;h2 id=&quot;vivo&quot;&gt;&lt;a href=&quot;#vivo&quot; class=&quot;headerlink&quot; title=&quot;vivo&quot;&gt;&lt;/a&gt;vivo&lt;/h2&gt;&lt;p&gt;找到了vivo的launcher的所有快捷方式所在的ContentProvider，&lt;code&gt;content://com.bbk.launcher2.settings/favorites&lt;/code&gt;遍历了一圈发现了一个字段叫&lt;code&gt;shortcutPermission&lt;/code&gt;，修改了权限后，这个值会有变化。&lt;/p&gt;
&lt;p&gt;有趣的是，初始化假如是禁止的情况，它的值是1，但是只要编辑过，就会变化成16（允许），17（禁止），18（询问，部分手机有这个选项）。&lt;/p&gt;
    
    </summary>
    
      <category term="android开发" scheme="http://www.lefo.me/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Notification通知栏的那些事</title>
    <link href="http://www.lefo.me/2017/03/04/notification-tips/"/>
    <id>http://www.lefo.me/2017/03/04/notification-tips/</id>
    <published>2017-03-04T18:48:50.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在安卓开发中，一定会使用Notification。而notification也随着Android版本的升级，一直在变化。这篇blog简单记录一下在Notification开发时，我所碰上的问题，以及需要注意的地方。</p><h1 id="碰上的问题"><a href="#碰上的问题" class="headerlink" title="碰上的问题"></a>碰上的问题</h1><h2 id="RemoteView的文字颜色"><a href="#RemoteView的文字颜色" class="headerlink" title="RemoteView的文字颜色"></a>RemoteView的文字颜色</h2><p>Android的ROM太多了，通知栏的颜色、样式都不尽相同。有的是白的，有的是黑的，这就让我们在自定义RemoteView的时候，不能直去设置文字的颜色，比如设置了白色，在白底的通知栏就没办法显示出文字。</p><p>怎么办？</p><a id="more"></a><p>/res/values/styles.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;NotificationText&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:textColor&quot;&gt;?android:attr/textColorPrimary&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;style name=&quot;NotificationTitle&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:textColor&quot;&gt;?android:attr/textColorPrimary&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>因为在安卓2.3以上的版本，系统提供了一个默认通知栏的文本颜色值，所以直接拿来用就好<br>/res/values-v9/styles.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;NotificationText&quot; parent=&quot;android:TextAppearance.StatusBar.EventContent&quot; /&gt;</span><br><span class="line">&lt;style name=&quot;NotificationTitle&quot; parent=&quot;android:TextAppearance.StatusBar.EventContent.Title&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>本以为这样就OK了，这块代码一直没有动，直到前几天，测试发现在华为P9上，7.0系统，别人家的通知栏是白色底的，而我家的通知栏是黑色的。。而且有一个诡异的现象就是，在7.0系统展开后一滑动，有一定几率变成白色底。</p><p><em>于是查啊查，终于发现，原来是gradle里面的<code>targetSdkVersion</code>，因为之前一直都是18，改成21以后就成了白色的了。</em></p><p>白色的倒是变了，但是之前黑色底的文字是白色的，现在成了白色底，却还是白色的文字。不墨迹，直接翻开Notification的源码，找到了默认的layout，终于发现，原来在5.0系统上，默认通知栏文本颜色值又重新定义了。我们需要在v21再加入以下代码</p><p><em>在EMUI和MIUI上，测试没有通过，发现还是用的v9的值，看来还是需要在代码里判断view的颜色值</em></p><p>/res/values-v21/styles.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;NotificationText&quot; parent=&quot;android:TextAppearance.Material.Notification&quot; /&gt;</span><br><span class="line">&lt;style name=&quot;NotificationTitle&quot; parent=&quot;android:TextAppearance.Material.Notification.Title&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>怎么使用我就不细说了，在layout的textview使用style属性应该都会。</p><p><em>在EMUI和MIUI上，测试没有通过，发现还是用的v9的值，看来还是需要在代码里判断view的颜色值</em></p><h2 id="点了通知栏不跳转"><a href="#点了通知栏不跳转" class="headerlink" title="点了通知栏不跳转"></a>点了通知栏不跳转</h2><p>有一次测试，发现在4.4的手机上，明明配置了正确的PendingIntent，然而，不管怎么点，都不能跳转到Activity，非常郁闷。最后，终于找到了资料。原来，是因为在创建PendingIntent的时候，我们使用了FLAG_UPDATE_CURRENT，在4.4的系统上，用FLAG_UPDATE_CURRENT的时候，Activity必须得是exported=true的才可以。</p><p>解决办法：改为FLAG_CANCEL_CURRENT 或者，在清单文件将落地Activity改为exported=true。</p><h2 id="根布局"><a href="#根布局" class="headerlink" title="根布局"></a>根布局</h2><p>我提一个建议就是，根布局使用LinearLayout，为什么呢？因为在有的coolpad的手机上，弹出一个通知后，会在你的通知布局上加一个View，然后让用户选择是否允许弹出，如果我们的布局是RelativeLayout或者FrameLayout，那它加上的两个按钮就会把咱们的控件覆盖掉。</p><h1 id="7-0的新特性"><a href="#7-0的新特性" class="headerlink" title="7.0的新特性"></a>7.0的新特性</h1><p>7.0的系统上，又有了一些新功能，附上google官方的博客介绍文章。<br><a href="https://android-developers.googleblog.com/2016/06/notifications-in-android-n.html" target="_blank" rel="noopener">https://android-developers.googleblog.com/2016/06/notifications-in-android-n.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在安卓开发中，一定会使用Notification。而notification也随着Android版本的升级，一直在变化。这篇blog简单记录一下在Notification开发时，我所碰上的问题，以及需要注意的地方。&lt;/p&gt;
&lt;h1 id=&quot;碰上的问题&quot;&gt;&lt;a href=&quot;#碰上的问题&quot; class=&quot;headerlink&quot; title=&quot;碰上的问题&quot;&gt;&lt;/a&gt;碰上的问题&lt;/h1&gt;&lt;h2 id=&quot;RemoteView的文字颜色&quot;&gt;&lt;a href=&quot;#RemoteView的文字颜色&quot; class=&quot;headerlink&quot; title=&quot;RemoteView的文字颜色&quot;&gt;&lt;/a&gt;RemoteView的文字颜色&lt;/h2&gt;&lt;p&gt;Android的ROM太多了，通知栏的颜色、样式都不尽相同。有的是白的，有的是黑的，这就让我们在自定义RemoteView的时候，不能直去设置文字的颜色，比如设置了白色，在白底的通知栏就没办法显示出文字。&lt;/p&gt;
&lt;p&gt;怎么办？&lt;/p&gt;
    
    </summary>
    
      <category term="android开发" scheme="http://www.lefo.me/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>应用市场的尔虞我诈（突破华为安装时来源检测）</title>
    <link href="http://www.lefo.me/2017/02/23/market-install-intercept/"/>
    <id>http://www.lefo.me/2017/02/23/market-install-intercept/</id>
    <published>2017-02-23T18:38:50.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>去年年底的时候，产品妹子拿着一部华为手机来找我们组，这部手机在安装应用的时候，会显示安装来源，同时，对包进行了扫描检测。但是有一个奇怪的现象是，同一款应用，安装过程不同。</p><ol><li>从我们市场安装，则显示出市场名字，并提示建议从官方市场安装，用户必须勾选允许才能安装，不然只能取消或去华为商店下载。</li><li>从豌豆荚中安装，显示的是未知来源，没有提示从官方市场安装。</li><li>从360手机助手、应用宝安装显示出市场名字，提示通过安全检测。</li></ol><p>这个安全引导在一定程度上能将我们的流量直接导入到官方市场下载。应用市场就是靠下载、安装的流量转化来赚钱的，而在安装的时候，ROM方就设置一些门槛，将量转化到自己的市场里。而且从上面的结果猜测，360和应用宝明显是走了公关渠道，而豌豆荚则是使用了黑科技。</p><a id="more"></a><h1 id="研究黑科技"><a href="#研究黑科技" class="headerlink" title="研究黑科技"></a>研究黑科技</h1><p>初步猜测是安装的时候，豌豆荚传递了某个参数，导致不能获取到来源的包名。因为安卓可以拦截安装的action，在安装前对包进行处理。配置如下intent-filter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class="line">&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">&lt;data android:scheme=&quot;file&quot;/&gt;</span><br><span class="line">&lt;data android:mimeType=&quot;application/vnd.android.package-archive&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure></p><p>安装的时候，会提示使用系统安装器，还是用你的程序。debug后发现intent的extra传了一个叫<code>caller_package</code>的参数。发现豌豆荚是传递了<code>com.google.launcher</code>。这个包是没有在手机上安装的（其实市场上也没有这个），所以显示未知来源。</p><p>于是在我们调用安装时加入了上面的参数。后来发现上面的这套方法，貌似只对应用有用，毕竟商业化的主要靠游戏。游戏安装暂时无解，放弃了。</p><p>附上对比图：<br><img src="/image/20170223/our.jpg" alt="我们的APP"><img src="/image/20170223/360.jpg" alt="360手机助手"></p><h1 id="新黑科技"><a href="#新黑科技" class="headerlink" title="新黑科技"></a>新黑科技</h1><p>上周五，产品妹子又来找我说，360手机助手在安装游戏的时候，有一个允许拦截网络的弹窗提示，只要取消了这个弹窗，一样会提示未经过官方市场检测提示，并推荐从官方市场安装。而如果在弹窗中点了允许，在安装的时候，就能绕过去。</p><p>这个弹窗就是VPN权限，之前并没有了解过<code>VpnService</code>，找了找资料。<br><a href="http://blog.csdn.net/jsqfengbao/article/details/52462125" target="_blank" rel="noopener">http://blog.csdn.net/jsqfengbao/article/details/52462125</a></p><p>简单说一下，Android中的Vpn框架并不是能直接让你连接另一个网络，只是将手机的流量都截获过来，具体用来做什么，框架中并没有实现。不过，这里只需要的是拦截网络，在无网的状态下，来源检测默认是通过。开启VpnService以后，状态栏会有一个钥匙的标识。</p><p>360手助和应用宝都有这个功能，在调用安装的时候，先启动VpnService，断掉了华为安装器的网络，导致在检测的时候，是无网的状态。</p><p>关于VpnService怎么使用，上面附上的文章有demo，这里只说一下如何断掉指定APP的网络。不推荐去分析网络包，虽然兼容性好，但太复杂，工程量太大。在<code>VpnService.Builder</code>中，有一个方法叫<code>addAllowedApplication</code>，将包名传递过去，就会让这个包的流量走你的VpnService，其它就不用处理了，反正是只要断开它的网。特别注意的是这个方法只在API 21以上的版本有。</p><p>效果图：<br><img src="/image/20170223/our-vpn.jpg" alt="加入VPN功能"></p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>昨天，给产品妹子发了个停安装器网络的demo，妹子和我说，她今天又试了一下，发现360手机助手在安装游戏的时候，弹窗点了取消，又能通过检测正常安装了。。。</p><p>猜测上周五，要么是停掉了允许通过的接口，要么就是有什么协议，某些时候可以转换转换量，哈哈，Interesting…</p><p>不管怎么样，黑科技还是好的。</p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>关于OPPO修改安装来源，又封装一下Intent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Intent actIntent = new Intent(&quot;oppo.intent.action.INSTALL_PACKAGE&quot;);</span><br><span class="line">Intent intent = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.putString(&quot;oppo_extra_pkg_name&quot;,packageName);</span><br><span class="line">//intent.setDataAndType</span><br><span class="line">//intent.setFlag</span><br><span class="line">actIntent.putExtra(&quot;android.intent.extra.INTENT&quot;, intent);</span><br></pre></td></tr></table></figure></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>慢慢的也有一些人问我vpn怎么实现，有一些伸手党，当前华为上失效了，也有来探讨说有没有什么新方法。目前还没有，从EMUI的现象上看，是在startActivity的时候，通过ActivityManagerService里面纠正了caller_package传的值，估计是华为已经发现了该方法。</p><p>VPN也失效了，华为在检测应用时，如果发现网络失败，就会立即清空所有的VPN服务，导致VPN当时就失效了，具体就不说了。</p><p>无解了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;去年年底的时候，产品妹子拿着一部华为手机来找我们组，这部手机在安装应用的时候，会显示安装来源，同时，对包进行了扫描检测。但是有一个奇怪的现象是，同一款应用，安装过程不同。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从我们市场安装，则显示出市场名字，并提示建议从官方市场安装，用户必须勾选允许才能安装，不然只能取消或去华为商店下载。&lt;/li&gt;
&lt;li&gt;从豌豆荚中安装，显示的是未知来源，没有提示从官方市场安装。&lt;/li&gt;
&lt;li&gt;从360手机助手、应用宝安装显示出市场名字，提示通过安全检测。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个安全引导在一定程度上能将我们的流量直接导入到官方市场下载。应用市场就是靠下载、安装的流量转化来赚钱的，而在安装的时候，ROM方就设置一些门槛，将量转化到自己的市场里。而且从上面的结果猜测，360和应用宝明显是走了公关渠道，而豌豆荚则是使用了黑科技。&lt;/p&gt;
    
    </summary>
    
      <category term="android开发" scheme="http://www.lefo.me/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Android沉浸式状态栏的实现</title>
    <link href="http://www.lefo.me/2016/09/05/translucent-status-bar/"/>
    <id>http://www.lefo.me/2016/09/05/translucent-status-bar/</id>
    <published>2016-09-05T20:01:50.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>从API 19开始，也就是android 4.4 kitcat，android开始支持沉浸式状态栏。可以使状态栏看起来和我们的程序浑然一体，不再像之前那样突兀。几个月前，刚好做了个这方面的需求，记录一下踩了的坑。</p><p>一共两种类型的沉浸式，一种是将view直接伸到statusbar里去，另一种是直接给statusbar设置一个背景色。其中，有些需要将伸到statusbar里的页面，顶部还有一个类似titlebar的view，有交互，必须保证操作区域没有进入到状态栏中。设置背景色的需求则比较简单，直接换个纯色的背景色。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>一顿的搜索前辈们的各种技术文章之后发现，一切效果都是：不理想。可以参考知乎上的一个问答<a href="https://www.zhihu.com/question/31468556" target="_blank" rel="noopener">Android 5.0 如何实现将布局的内容延伸到状态栏</a>，网上也找了一些开源类，大多修改状态栏颜色的和布局伸入状态栏的是分开的，没有在一起介绍的。而且发现有些方法中介绍的fitsSystemWindows属性的办法，对我来说简直就是噩梦，布局太复杂，试了好多遍都没成功。</p><a id="more"></a><h2 id="修改状态栏颜色的方法"><a href="#修改状态栏颜色的方法" class="headerlink" title="修改状态栏颜色的方法"></a>修改状态栏颜色的方法</h2><p>4.4的版本和5.x的版本，实现方式还有点区别。4.4是没有提供直接改状态栏的办法的，如果要修改状态栏颜色，就需要将状态栏直接隐藏，再在根布局上增加一个statusbar等高的view。</p><p>而在5.x的系统上，有一个方法叫，setStatusBarColor，可以直接修改状态栏的颜色。</p><p>4.4隐藏状态栏的代码如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Window window =  mActivity.getWindow();</span><br><span class="line">window.addFlags(Window.FLAG_TRANSLUCENT_STATUS);</span><br></pre></td></tr></table></figure></p><p>设置颜色比较简单，在4.4的系统，调用<code>addFlags(Window.FLAG_TRANSLUCENT_STATUS)</code>，然后在根布局add一个状态栏高度的view；在5.x以上的系统，调用<code>setStatusBarColor</code>，就OK了。</p><h2 id="将布局延伸到状态栏"><a href="#将布局延伸到状态栏" class="headerlink" title="将布局延伸到状态栏"></a>将布局延伸到状态栏</h2><p>将布局延伸到状态栏，需要做的就是隐藏掉状态栏，最初我也是按照搜索到的资料介绍，在5.x的系统上使用以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</span><br><span class="line">                    | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);</span><br><span class="line">window.addFlags(Window.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">window.setStatusBarColor(Color.TRANSPARENT);</span><br></pre></td></tr></table></figure><p>结果，测试发现在华为EMUI 3.x的5.x系统上，沉浸式状态栏的效果失效了。于是在5.0的系统上，改成了在调用<code>setStatusBarColor</code>之前，调用<code>addFlags(Window.FLAG_TRANSLUCENT_STATUS)</code>，没有使用上面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.addFlags(Window.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">window.setStatusBarColor(Color.TRANSPARENT);</span><br></pre></td></tr></table></figure><p>实践发现<code>addFlag(FLAG_TRANSLUCENT_STATUS)</code>就能让状态栏隐藏，在4.4中，有一层由深变浅的渐变遮罩（这个貌似没办法），不会覆盖整个状态栏；在5.x的手机上，会有一个半透明的黑色遮罩，这个是覆盖的整个状态栏位置的。</p><p>为了解决5.0的黑色遮罩的问题，就需要调用<code>window.setStatusBarColor(Color.TRANSPARENT)</code>，将状态栏完全设置成全透明的。</p><h2 id="布局复杂"><a href="#布局复杂" class="headerlink" title="布局复杂"></a>布局复杂</h2><p>但是，在隐藏掉以后，实际上，时间、wifi、通知等这些都会存在，顶部的titlebar就需要向下移动statusbar的高度，否则，时间，信号，wifi这些会覆盖在titlebar上面。</p><p>解决的办法就是，需要将titlebar的位置，向下移动一个statusbar高度。由于这种类型的页面比较少，所以直接在有titlebar的布局中，include增加了一个0dp高度的view，而在需要将其显示时，初始化时修改view的高度。</p><p>为了修改颜色和布局伸入状态栏可以统一处理，statusbar就完全隐藏掉，再增加一个statusbar高度的自定义背景色的view。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>因为项目sdk版本的原因，我直接把Window类一些字段复制出来了。调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StatusBarManager statusBarManager = new StatusBarManager(activity);</span><br><span class="line">//这里如果要移动titlebar，则在布局中指定为include的自定义statusbar的view</span><br><span class="line">//如果不指定，则调用setStatusBarView();会自动加一个view</span><br><span class="line">statusBarManager.setStatusBarView(view);</span><br></pre></td></tr></table></figure><p>另外，有些布局，在伸入到状态栏以后，给用户展示的区域就会变小，这个没办法，需要手动调整，只要调用<code>statusBarManager.getStatusBarHeight()</code>，此方法（注意这里不是静态方法，静态方法有参数，是获取系统状态栏的高度的）会返回view的高度，如果没有就是0，所以调用时不用做是否api 19+的版本判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">public class StatusBarManager &#123;</span><br><span class="line"></span><br><span class="line">    private static final int BUILD_VERSION_KITKAT = 19;</span><br><span class="line">    private static final int BUILD_VERSION_LOLLIPOP = 21;</span><br><span class="line"></span><br><span class="line">    //WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS</span><br><span class="line">    public static final int FLAG_TRANSLUCENT_STATUS = 0x04000000;</span><br><span class="line"></span><br><span class="line">    //WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</span><br><span class="line">    public static final int FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS = 0x80000000;</span><br><span class="line"></span><br><span class="line">    private Activity mActivity;</span><br><span class="line">    private View statusBarView;</span><br><span class="line">    private int statusBarHeight;</span><br><span class="line"></span><br><span class="line">    public StatusBarManager(Activity activity) &#123;</span><br><span class="line">        this.mActivity = activity;</span><br><span class="line">        statusBarHeight = getStatusBarHeight(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStatusBarView(View statusBarView) &#123;</span><br><span class="line">        this.statusBarView = statusBarView;</span><br><span class="line">        setTransparent();</span><br><span class="line">    &#125;</span><br><span class="line">    public void setStatusBarView() &#123;</span><br><span class="line">        setTransparent();</span><br><span class="line">    &#125;</span><br><span class="line">    public int getStatusBarHeight() &#123;</span><br><span class="line">        return statusBarHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置状态栏全透明</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    private void setTransparent() &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &lt; BUILD_VERSION_KITKAT) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(statusBarHeight &lt;= 0)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        transparentStatusBar();</span><br><span class="line">        showStatusBarView();</span><br><span class="line">    &#125;</span><br><span class="line">    @TargetApi(19)</span><br><span class="line">    private void showStatusBarView() &#123;</span><br><span class="line">        int color = mActivity.getResources().getColor(R.color.main_color);</span><br><span class="line">        if(statusBarView == null)&#123;</span><br><span class="line">            statusBarView = new View(mActivity);</span><br><span class="line">            LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                    getStatusBarHeight(mActivity));</span><br><span class="line">            statusBarView.setLayoutParams(params);</span><br><span class="line">            statusBarView.setBackgroundColor(color);</span><br><span class="line">            ViewGroup decorView = (ViewGroup) mActivity.getWindow().getDecorView();</span><br><span class="line">            FrameLayout content = (FrameLayout) decorView.findViewById(android.R.id.content);</span><br><span class="line">            FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) content.getChildAt(0).getLayoutParams();</span><br><span class="line">            layoutParams.setMargins(0,statusBarHeight,0,0);</span><br><span class="line">            decorView.addView(statusBarView);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ViewGroup.LayoutParams layoutParams = statusBarView.getLayoutParams();</span><br><span class="line">            layoutParams.height = getStatusBarHeight(mActivity);</span><br><span class="line">            statusBarView.setLayoutParams(layoutParams);</span><br><span class="line">            statusBarView.setBackgroundColor(color);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //参考上面注释掉的代码 因为需要用隐藏API 调用方式进行改成反射</span><br><span class="line">    private void transparentStatusBar()&#123;</span><br><span class="line">        Window window =  mActivity.getWindow();</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= BUILD_VERSION_LOLLIPOP) &#123;</span><br><span class="line">            //不add此条flag 会导致在EMUI3.1(华为)上失效，add这个flag 会导致在其它机型上面添加一个半透明黑条</span><br><span class="line">            window.addFlags(FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">            //下面的代码段是不加上面的flag时，要显示纯色的状态栏时需要加的代码 不用了</span><br><span class="line">/*            window.clearFlags(FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">            window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</span><br><span class="line">                    | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);</span><br><span class="line">            window.addFlags(FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);*/</span><br><span class="line">//因为需要用隐藏API，没有重新编译5.x版本的android.jar，使用的还是18的api，这里用的反射</span><br><span class="line">            try &#123;</span><br><span class="line">                Class[] argsClass=new Class[]&#123;int.class&#125;;</span><br><span class="line">                Method setStatusBarColorMethod = Window.class.getMethod(&quot;setStatusBarColor&quot;,argsClass);</span><br><span class="line">                setStatusBarColorMethod.invoke(window, Color.TRANSPARENT);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            window.addFlags(FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取状态栏高度</span><br><span class="line">     *</span><br><span class="line">     * @param context context</span><br><span class="line">     * @return 状态栏高度</span><br><span class="line">     */</span><br><span class="line">    private static int getStatusBarHeight(Context context) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &lt; BUILD_VERSION_KITKAT) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获得状态栏高度</span><br><span class="line">        int resourceId = context.getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;);</span><br><span class="line">        return context.getResources().getDimensionPixelSize(resourceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStatusbarVisibility(int visibility)&#123;</span><br><span class="line">        if(statusBarView != null) &#123;</span><br><span class="line">            this.statusBarView.setVisibility(visibility);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setColor(int color)&#123;</span><br><span class="line">        if(statusBarView != null)&#123;</span><br><span class="line">            this.statusBarView.setBackgroundColor(color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;p&gt;从API 19开始，也就是android 4.4 kitcat，android开始支持沉浸式状态栏。可以使状态栏看起来和我们的程序浑然一体，不再像之前那样突兀。几个月前，刚好做了个这方面的需求，记录一下踩了的坑。&lt;/p&gt;
&lt;p&gt;一共两种类型的沉浸式，一种是将view直接伸到statusbar里去，另一种是直接给statusbar设置一个背景色。其中，有些需要将伸到statusbar里的页面，顶部还有一个类似titlebar的view，有交互，必须保证操作区域没有进入到状态栏中。设置背景色的需求则比较简单，直接换个纯色的背景色。&lt;/p&gt;
&lt;h1 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h1&gt;&lt;p&gt;一顿的搜索前辈们的各种技术文章之后发现，一切效果都是：不理想。可以参考知乎上的一个问答&lt;a href=&quot;https://www.zhihu.com/question/31468556&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 5.0 如何实现将布局的内容延伸到状态栏&lt;/a&gt;，网上也找了一些开源类，大多修改状态栏颜色的和布局伸入状态栏的是分开的，没有在一起介绍的。而且发现有些方法中介绍的fitsSystemWindows属性的办法，对我来说简直就是噩梦，布局太复杂，试了好多遍都没成功。&lt;/p&gt;
    
    </summary>
    
      <category term="android开发" scheme="http://www.lefo.me/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="android" scheme="http://www.lefo.me/tags/android/"/>
    
      <category term="状态栏" scheme="http://www.lefo.me/tags/%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>编译Android源码，使用hide api和internal api</title>
    <link href="http://www.lefo.me/2016/07/26/compile-android-source/"/>
    <id>http://www.lefo.me/2016/07/26/compile-android-source/</id>
    <published>2016-07-26T19:00:46.000Z</published>
    <updated>2021-02-24T11:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为项目需要，有部分代码调用了Hide api，需要没有被阉割的android.jar。对于5.0以前的系统，这个jar可以从手机的framework.apk中提取，利用dex2jar变成jar，再覆盖SDK中的jar包中相同类名（sdk中有些类不是framework下的，framework只是一个模块，需要覆盖合并）。从5.0以上开始后，这个方法就不行了，必须自己生成jar包来使用。</p><h1 id="官方说明"><a href="#官方说明" class="headerlink" title="官方说明"></a>官方说明</h1><p><a href="https://source.android.com/source/index.html" target="_blank" rel="noopener">https://source.android.com/source/index.html</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/</a></p><a id="more"></a><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># fetch source</span><br><span class="line">sudo yum install git</span><br><span class="line">sudo yum install wget</span><br><span class="line"># to compile</span><br><span class="line">sudo yum install java-1.7.0-openjdk</span><br><span class="line">sudo yum install java-1.7.0-openjdk-devel</span><br><span class="line">sudo yum install glibc.i686</span><br><span class="line">sudo yum install libstdc++.i686</span><br><span class="line">sudo yum install bison</span><br><span class="line">sudo yum install zip</span><br><span class="line">sudo yum install unzip</span><br></pre></td></tr></table></figure><p>编译时候，如果提示找不到某个.so库，可以使用yum whatprovides 这个命令来搜索缺少的软件<br>如我的就缺少 ld-linux.so.2(因为我没有按上面的包来安装，都是编译时候缺少什么装什么软件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum whatprovides ld-linux.so.2</span><br></pre></td></tr></table></figure></p><p>安装某个软件提示protected multilib version    yum –setopt=protected_multilib=false</p><p>libz.so.1 zlib-1.2.7-13.el7.i686</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>下载repo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:$PATH</span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure></p><p>创建工作目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir WORKING_DIRECTORY</span><br><span class="line">cd WORKING_DIRECTORY</span><br></pre></td></tr></table></figure></p><p>初始化仓库，这里需要连接google，我走了代理，没有修改REPO，不清楚修改repo行不行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest</span><br><span class="line">## 如果提示无法连接到 gerrit.googlesource.com，可以编辑 ~/bin/repo，把 REPO_URL 一行替换成下面的：</span><br><span class="line">REPO_URL = &apos;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&apos;</span><br></pre></td></tr></table></figure></p><p>下载，同步源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-6.0.1_r1</span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure></p><p>设置代理，我没有使用清华的repo_url，因为公司的电脑默认可以翻墙（虚机不允许），就直接改了个代理搞定了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export HTTP_PROXY=http://your proxy ip:8888</span><br><span class="line">export HTTPS_PROXY=http://your proxy ip:8888</span><br><span class="line">#取消代理</span><br><span class="line">export -n HTTP_PROXY</span><br></pre></td></tr></table></figure></p><p>编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. build/envsetup.sh</span><br><span class="line">lunch aosp_arm-eng</span><br><span class="line">make -j16</span><br></pre></td></tr></table></figure></p><p>编译SDK(编译sdk的时候用，这里不用执行，只是介绍一下，有上面的命令就够了)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lunch sdk_sdk-eng</span><br><span class="line">make sdk</span><br></pre></td></tr></table></figure></p><h1 id="使用hide-api和internal-api"><a href="#使用hide-api和internal-api" class="headerlink" title="使用hide api和internal api"></a>使用hide api和internal api</h1><p>之前我想一步到位直接编译出android.jar，将源码中带有@hide标记的代码进行处理，使其在<code>make sdk</code>的时候，不要删除这些代码。修改方法 ：去掉代码中的<code>@hide</code>比较不现实，太多了。经整理发现，进行hide api处理，其实是在生成api doc的时候，关键的代码在./external/doclava/目录下。我们修改<code>Stub</code>类，可以达到目的。</p><p>后来发现，在编译android.jar的时候，是有一个类的映射，有一个文件保存需要将哪些类打入到android.jar。上面的方法只处理了android.jar中的hide api，而还有<code>internal</code>的代码还是没能打入jar。</p><p>于是，只好使用<code>make -j32</code>命令，直接都编译了一圈，然后标准sdk中的jar进行合并，生成了包含<code>internal</code>的jar包.</p><p>framework目录：<code>out/target/common/obj/JAVA_LIBRARIES/framework_intermediate</code><br>SDK的android.jar目录：<code>out/target/common/obj/JAVA_LIBRARIES/android_stubs_current_intermediates</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为项目需要，有部分代码调用了Hide api，需要没有被阉割的android.jar。对于5.0以前的系统，这个jar可以从手机的framework.apk中提取，利用dex2jar变成jar，再覆盖SDK中的jar包中相同类名（sdk中有些类不是framework下的，framework只是一个模块，需要覆盖合并）。从5.0以上开始后，这个方法就不行了，必须自己生成jar包来使用。&lt;/p&gt;
&lt;h1 id=&quot;官方说明&quot;&gt;&lt;a href=&quot;#官方说明&quot; class=&quot;headerlink&quot; title=&quot;官方说明&quot;&gt;&lt;/a&gt;官方说明&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://source.android.com/source/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://source.android.com/source/index.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="android开发" scheme="http://www.lefo.me/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="android" scheme="http://www.lefo.me/tags/android/"/>
    
      <category term="source" scheme="http://www.lefo.me/tags/source/"/>
    
  </entry>
  
</feed>
